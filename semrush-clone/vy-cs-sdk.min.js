var VoyantisSDK = function(t) {
    "use strict";
    var e, n, r = function() {
        return r = Object.assign || function(t) {
            for (var e, n = 1, r = arguments.length; n < r; n++)
                for (var o in e = arguments[n])
                    Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
            return t
        }
        ,
        r.apply(this, arguments)
    };
    function o(t, e, n, r) {
        return new (n || (n = Promise))((function(o, s) {
            function i(t) {
                try {
                    c(r.next(t))
                } catch (t) {
                    s(t)
                }
            }
            function a(t) {
                try {
                    c(r.throw(t))
                } catch (t) {
                    s(t)
                }
            }
            function c(t) {
                var e;
                t.done ? o(t.value) : (e = t.value,
                e instanceof n ? e : new n((function(t) {
                    t(e)
                }
                ))).then(i, a)
            }
            c((r = r.apply(t, e || [])).next())
        }
        ))
    }
    function s(t, e) {
        var n, r, o, s = {
            label: 0,
            sent: function() {
                if (1 & o[0])
                    throw o[1];
                return o[1]
            },
            trys: [],
            ops: []
        }, i = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
        return i.next = a(0),
        i.throw = a(1),
        i.return = a(2),
        "function" == typeof Symbol && (i[Symbol.iterator] = function() {
            return this
        }
        ),
        i;
        function a(a) {
            return function(c) {
                return function(a) {
                    if (n)
                        throw new TypeError("Generator is already executing.");
                    for (; i && (i = 0,
                    a[0] && (s = 0)),
                    s; )
                        try {
                            if (n = 1,
                            r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r),
                            0) : r.next) && !(o = o.call(r, a[1])).done)
                                return o;
                            switch (r = 0,
                            o && (a = [2 & a[0], o.value]),
                            a[0]) {
                            case 0:
                            case 1:
                                o = a;
                                break;
                            case 4:
                                return s.label++,
                                {
                                    value: a[1],
                                    done: !1
                                };
                            case 5:
                                s.label++,
                                r = a[1],
                                a = [0];
                                continue;
                            case 7:
                                a = s.ops.pop(),
                                s.trys.pop();
                                continue;
                            default:
                                if (!(o = s.trys,
                                (o = o.length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                    s = 0;
                                    continue
                                }
                                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                                    s.label = a[1];
                                    break
                                }
                                if (6 === a[0] && s.label < o[1]) {
                                    s.label = o[1],
                                    o = a;
                                    break
                                }
                                if (o && s.label < o[2]) {
                                    s.label = o[2],
                                    s.ops.push(a);
                                    break
                                }
                                o[2] && s.ops.pop(),
                                s.trys.pop();
                                continue
                            }
                            a = e.call(t, s)
                        } catch (t) {
                            a = [6, t],
                            r = 0
                        } finally {
                            n = o = 0
                        }
                    if (5 & a[0])
                        throw a[1];
                    return {
                        value: a[0] ? a[1] : void 0,
                        done: !0
                    }
                }([a, c])
            }
        }
    }
    function i(t) {
        for (var r = [], o = 1; o < arguments.length; o++)
            r[o - 1] = arguments[o];
        var s, i, a, c = (s = "vy_debug_mode",
        i = new RegExp("[?&]".concat(s, "=([^&#]*)"),"i"),
        (a = window.location.search.match(i)) ? decodeURIComponent(a[1]) : null);
        ("prod" !== e || c) && console[t].apply(console, function(t, e, n) {
            if (n || 2 === arguments.length)
                for (var r, o = 0, s = e.length; o < s; o++)
                    !r && o in e || (r || (r = Array.prototype.slice.call(e, 0, o)),
                    r[o] = e[o]);
            return t.concat(r || Array.prototype.slice.call(e))
        }(["Voyantis: [".concat(e, "] [version: ").concat(n, "] [").concat(t, "]")], r, !1))
    }
    "function" == typeof SuppressedError && SuppressedError;
    const a = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
      , c = "8.40.0"
      , u = globalThis;
    function d(t, e, n) {
        const r = u
          , o = r.__SENTRY__ = r.__SENTRY__ || {}
          , s = o[c] = o[c] || {};
        return s[t] || (s[t] = e())
    }
    const p = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
      , l = ["debug", "info", "warn", "error", "log", "assert", "trace"]
      , f = {};
    function h(t) {
        if (!("console"in u))
            return t();
        const e = u.console
          , n = {}
          , r = Object.keys(f);
        r.forEach((t => {
            const r = f[t];
            n[t] = e[t],
            e[t] = r
        }
        ));
        try {
            return t()
        } finally {
            r.forEach((t => {
                e[t] = n[t]
            }
            ))
        }
    }
    const m = d("logger", (function() {
        let t = !1;
        const e = {
            enable: () => {
                t = !0
            }
            ,
            disable: () => {
                t = !1
            }
            ,
            isEnabled: () => t
        };
        return p ? l.forEach((n => {
            e[n] = (...e) => {
                t && h(( () => {
                    u.console[n](`Sentry Logger [${n}]:`, ...e)
                }
                ))
            }
        }
        )) : l.forEach((t => {
            e[t] = () => {}
        }
        )),
        e
    }
    ))
      , g = "?"
      , _ = /\(error: (.*)\)/
      , v = /captureMessage|captureException/;
    function y(...t) {
        const e = t.sort(( (t, e) => t[0] - e[0])).map((t => t[1]));
        return (t, n=0, r=0) => {
            const o = []
              , s = t.split("\n");
            for (let t = n; t < s.length; t++) {
                const n = s[t];
                if (n.length > 1024)
                    continue;
                const i = _.test(n) ? n.replace(_, "$1") : n;
                if (!i.match(/\S*Error: /)) {
                    for (const t of e) {
                        const e = t(i);
                        if (e) {
                            o.push(e);
                            break
                        }
                    }
                    if (o.length >= 50 + r)
                        break
                }
            }
            return function(t) {
                if (!t.length)
                    return [];
                const e = Array.from(t);
                /sentryWrapped/.test(b(e).function || "") && e.pop();
                e.reverse(),
                v.test(b(e).function || "") && (e.pop(),
                v.test(b(e).function || "") && e.pop());
                return e.slice(0, 50).map((t => ({
                    ...t,
                    filename: t.filename || b(e).filename,
                    function: t.function || g
                })))
            }(o.slice(r))
        }
    }
    function b(t) {
        return t[t.length - 1] || {}
    }
    const S = "<anonymous>";
    function E(t) {
        try {
            return t && "function" == typeof t && t.name || S
        } catch (t) {
            return S
        }
    }
    function w(t) {
        const e = t.exception;
        if (e) {
            const t = [];
            try {
                return e.values.forEach((e => {
                    e.stacktrace.frames && t.push(...e.stacktrace.frames)
                }
                )),
                t
            } catch (t) {
                return
            }
        }
    }
    const T = {}
      , x = {};
    function k(t, e) {
        T[t] = T[t] || [],
        T[t].push(e)
    }
    function I(t, e) {
        if (!x[t]) {
            x[t] = !0;
            try {
                e()
            } catch (e) {
                p && m.error(`Error while instrumenting ${t}`, e)
            }
        }
    }
    function A(t, e) {
        const n = t && T[t];
        if (n)
            for (const r of n)
                try {
                    r(e)
                } catch (e) {
                    p && m.error(`Error while triggering instrumentation handler.\nType: ${t}\nName: ${E(r)}\nError:`, e)
                }
    }
    let O = null;
    function P(t) {
        const e = "error";
        k(e, t),
        I(e, C)
    }
    function C() {
        O = u.onerror,
        u.onerror = function(t, e, n, r, o) {
            return A("error", {
                column: r,
                error: o,
                line: n,
                msg: t,
                url: e
            }),
            !(!O || O.__SENTRY_LOADER__) && O.apply(this, arguments)
        }
        ,
        u.onerror.__SENTRY_INSTRUMENTED__ = !0
    }
    let $ = null;
    function D(t) {
        const e = "unhandledrejection";
        k(e, t),
        I(e, R)
    }
    function R() {
        $ = u.onunhandledrejection,
        u.onunhandledrejection = function(t) {
            return A("unhandledrejection", t),
            !($ && !$.__SENTRY_LOADER__) || $.apply(this, arguments)
        }
        ,
        u.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
    }
    function L() {
        return N(u),
        u
    }
    function N(t) {
        const e = t.__SENTRY__ = t.__SENTRY__ || {};
        return e.version = e.version || c,
        e[c] = e[c] || {}
    }
    const M = Object.prototype.toString;
    function j(t) {
        switch (M.call(t)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
        case "[object WebAssembly.Exception]":
            return !0;
        default:
            return Y(t, Error)
        }
    }
    function U(t, e) {
        return M.call(t) === `[object ${e}]`
    }
    function q(t) {
        return U(t, "ErrorEvent")
    }
    function F(t) {
        return U(t, "DOMError")
    }
    function G(t) {
        return U(t, "String")
    }
    function H(t) {
        return "object" == typeof t && null !== t && "__sentry_template_string__"in t && "__sentry_template_values__"in t
    }
    function B(t) {
        return null === t || H(t) || "object" != typeof t && "function" != typeof t
    }
    function z(t) {
        return U(t, "Object")
    }
    function V(t) {
        return "undefined" != typeof Event && Y(t, Event)
    }
    function W(t) {
        return Boolean(t && t.then && "function" == typeof t.then)
    }
    function Y(t, e) {
        try {
            return t instanceof e
        } catch (t) {
            return !1
        }
    }
    function X(t) {
        return !("object" != typeof t || null === t || !t.__isVue && !t._isVue)
    }
    const J = u;
    function K(t, e={}) {
        if (!t)
            return "<unknown>";
        try {
            let n = t;
            const r = 5
              , o = [];
            let s = 0
              , i = 0;
            const a = " > "
              , c = a.length;
            let u;
            const d = Array.isArray(e) ? e : e.keyAttrs
              , p = !Array.isArray(e) && e.maxStringLength || 80;
            for (; n && s++ < r && (u = Q(n, d),
            !("html" === u || s > 1 && i + o.length * c + u.length >= p)); )
                o.push(u),
                i += u.length,
                n = n.parentNode;
            return o.reverse().join(a)
        } catch (t) {
            return "<unknown>"
        }
    }
    function Q(t, e) {
        const n = t
          , r = [];
        if (!n || !n.tagName)
            return "";
        if (J.HTMLElement && n instanceof HTMLElement && n.dataset) {
            if (n.dataset.sentryComponent)
                return n.dataset.sentryComponent;
            if (n.dataset.sentryElement)
                return n.dataset.sentryElement
        }
        r.push(n.tagName.toLowerCase());
        const o = e && e.length ? e.filter((t => n.getAttribute(t))).map((t => [t, n.getAttribute(t)])) : null;
        if (o && o.length)
            o.forEach((t => {
                r.push(`[${t[0]}="${t[1]}"]`)
            }
            ));
        else {
            n.id && r.push(`#${n.id}`);
            const t = n.className;
            if (t && G(t)) {
                const e = t.split(/\s+/);
                for (const t of e)
                    r.push(`.${t}`)
            }
        }
        const s = ["aria-label", "type", "name", "title", "alt"];
        for (const t of s) {
            const e = n.getAttribute(t);
            e && r.push(`[${t}="${e}"]`)
        }
        return r.join("")
    }
    function Z(t) {
        if (!J.HTMLElement)
            return null;
        let e = t;
        for (let t = 0; t < 5; t++) {
            if (!e)
                return null;
            if (e instanceof HTMLElement) {
                if (e.dataset.sentryComponent)
                    return e.dataset.sentryComponent;
                if (e.dataset.sentryElement)
                    return e.dataset.sentryElement
            }
            e = e.parentNode
        }
        return null
    }
    function tt(t, e=0) {
        return "string" != typeof t || 0 === e || t.length <= e ? t : `${t.slice(0, e)}...`
    }
    function et(t, e) {
        if (!Array.isArray(t))
            return "";
        const n = [];
        for (let e = 0; e < t.length; e++) {
            const r = t[e];
            try {
                X(r) ? n.push("[VueViewModel]") : n.push(String(r))
            } catch (t) {
                n.push("[value cannot be serialized]")
            }
        }
        return n.join(e)
    }
    function nt(t, e, n=!1) {
        return !!G(t) && (U(e, "RegExp") ? e.test(t) : !!G(e) && (n ? t === e : t.includes(e)))
    }
    function rt(t, e=[], n=!1) {
        return e.some((e => nt(t, e, n)))
    }
    function ot(t, e, n) {
        if (!(e in t))
            return;
        const r = t[e]
          , o = n(r);
        "function" == typeof o && it(o, r);
        try {
            t[e] = o
        } catch (n) {
            p && m.log(`Failed to replace method "${e}" in object`, t)
        }
    }
    function st(t, e, n) {
        try {
            Object.defineProperty(t, e, {
                value: n,
                writable: !0,
                configurable: !0
            })
        } catch (n) {
            p && m.log(`Failed to add non-enumerable property "${e}" to object`, t)
        }
    }
    function it(t, e) {
        try {
            const n = e.prototype || {};
            t.prototype = e.prototype = n,
            st(t, "__sentry_original__", e)
        } catch (t) {}
    }
    function at(t) {
        return t.__sentry_original__
    }
    function ct(t) {
        if (j(t))
            return {
                message: t.message,
                name: t.name,
                stack: t.stack,
                ...dt(t)
            };
        if (V(t)) {
            const e = {
                type: t.type,
                target: ut(t.target),
                currentTarget: ut(t.currentTarget),
                ...dt(t)
            };
            return "undefined" != typeof CustomEvent && Y(t, CustomEvent) && (e.detail = t.detail),
            e
        }
        return t
    }
    function ut(t) {
        try {
            return e = t,
            "undefined" != typeof Element && Y(e, Element) ? K(t) : Object.prototype.toString.call(t)
        } catch (t) {
            return "<unknown>"
        }
        var e
    }
    function dt(t) {
        if ("object" == typeof t && null !== t) {
            const e = {};
            for (const n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e
        }
        return {}
    }
    function pt(t) {
        return lt(t, new Map)
    }
    function lt(t, e) {
        if (function(t) {
            if (!z(t))
                return !1;
            try {
                const e = Object.getPrototypeOf(t).constructor.name;
                return !e || "Object" === e
            } catch (t) {
                return !0
            }
        }(t)) {
            const n = e.get(t);
            if (void 0 !== n)
                return n;
            const r = {};
            e.set(t, r);
            for (const n of Object.getOwnPropertyNames(t))
                void 0 !== t[n] && (r[n] = lt(t[n], e));
            return r
        }
        if (Array.isArray(t)) {
            const n = e.get(t);
            if (void 0 !== n)
                return n;
            const r = [];
            return e.set(t, r),
            t.forEach((t => {
                r.push(lt(t, e))
            }
            )),
            r
        }
        return t
    }
    function ft() {
        return Date.now() / 1e3
    }
    const ht = function() {
        const {performance: t} = u;
        if (!t || !t.now)
            return ft;
        const e = Date.now() - t.now()
          , n = null == t.timeOrigin ? e : t.timeOrigin;
        return () => (n + t.now()) / 1e3
    }()
      , mt = ( () => {
        const {performance: t} = u;
        if (!t || !t.now)
            return;
        const e = 36e5
          , n = t.now()
          , r = Date.now()
          , o = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e
          , s = o < e
          , i = t.timing && t.timing.navigationStart
          , a = "number" == typeof i ? Math.abs(i + n - r) : e;
        return s || a < e ? o <= a ? t.timeOrigin : i : r
    }
    )();
    function gt() {
        const t = u
          , e = t.crypto || t.msCrypto;
        let n = () => 16 * Math.random();
        try {
            if (e && e.randomUUID)
                return e.randomUUID().replace(/-/g, "");
            e && e.getRandomValues && (n = () => {
                const t = new Uint8Array(1);
                return e.getRandomValues(t),
                t[0]
            }
            )
        } catch (t) {}
        return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (t => (t ^ (15 & n()) >> t / 4).toString(16)))
    }
    function _t(t) {
        return t.exception && t.exception.values ? t.exception.values[0] : void 0
    }
    function vt(t) {
        const {message: e, event_id: n} = t;
        if (e)
            return e;
        const r = _t(t);
        return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
    }
    function yt(t, e, n) {
        const r = t.exception = t.exception || {}
          , o = r.values = r.values || []
          , s = o[0] = o[0] || {};
        s.value || (s.value = e || ""),
        s.type || (s.type = "Error")
    }
    function bt(t, e) {
        const n = _t(t);
        if (!n)
            return;
        const r = n.mechanism;
        if (n.mechanism = {
            type: "generic",
            handled: !0,
            ...r,
            ...e
        },
        e && "data"in e) {
            const t = {
                ...r && r.data,
                ...e.data
            };
            n.mechanism.data = t
        }
    }
    function St(t) {
        if (t && t.__sentry_captured__)
            return !0;
        try {
            st(t, "__sentry_captured__", !0)
        } catch (t) {}
        return !1
    }
    var Et;
    function wt(t) {
        return new xt((e => {
            e(t)
        }
        ))
    }
    function Tt(t) {
        return new xt(( (e, n) => {
            n(t)
        }
        ))
    }
    !function(t) {
        t[t.PENDING = 0] = "PENDING";
        t[t.RESOLVED = 1] = "RESOLVED";
        t[t.REJECTED = 2] = "REJECTED"
    }(Et || (Et = {}));
    class xt {
        constructor(t) {
            xt.prototype.__init.call(this),
            xt.prototype.__init2.call(this),
            xt.prototype.__init3.call(this),
            xt.prototype.__init4.call(this),
            this._state = Et.PENDING,
            this._handlers = [];
            try {
                t(this._resolve, this._reject)
            } catch (t) {
                this._reject(t)
            }
        }
        then(t, e) {
            return new xt(( (n, r) => {
                this._handlers.push([!1, e => {
                    if (t)
                        try {
                            n(t(e))
                        } catch (t) {
                            r(t)
                        }
                    else
                        n(e)
                }
                , t => {
                    if (e)
                        try {
                            n(e(t))
                        } catch (t) {
                            r(t)
                        }
                    else
                        r(t)
                }
                ]),
                this._executeHandlers()
            }
            ))
        }
        catch(t) {
            return this.then((t => t), t)
        }
        finally(t) {
            return new xt(( (e, n) => {
                let r, o;
                return this.then((e => {
                    o = !1,
                    r = e,
                    t && t()
                }
                ), (e => {
                    o = !0,
                    r = e,
                    t && t()
                }
                )).then(( () => {
                    o ? n(r) : e(r)
                }
                ))
            }
            ))
        }
        __init() {
            this._resolve = t => {
                this._setResult(Et.RESOLVED, t)
            }
        }
        __init2() {
            this._reject = t => {
                this._setResult(Et.REJECTED, t)
            }
        }
        __init3() {
            this._setResult = (t, e) => {
                this._state === Et.PENDING && (W(e) ? e.then(this._resolve, this._reject) : (this._state = t,
                this._value = e,
                this._executeHandlers()))
            }
        }
        __init4() {
            this._executeHandlers = () => {
                if (this._state === Et.PENDING)
                    return;
                const t = this._handlers.slice();
                this._handlers = [],
                t.forEach((t => {
                    t[0] || (this._state === Et.RESOLVED && t[1](this._value),
                    this._state === Et.REJECTED && t[2](this._value),
                    t[0] = !0)
                }
                ))
            }
        }
    }
    function kt(t) {
        const e = ht()
          , n = {
            sid: gt(),
            init: !0,
            timestamp: e,
            started: e,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => function(t) {
                return pt({
                    sid: `${t.sid}`,
                    init: t.init,
                    started: new Date(1e3 * t.started).toISOString(),
                    timestamp: new Date(1e3 * t.timestamp).toISOString(),
                    status: t.status,
                    errors: t.errors,
                    did: "number" == typeof t.did || "string" == typeof t.did ? `${t.did}` : void 0,
                    duration: t.duration,
                    abnormal_mechanism: t.abnormal_mechanism,
                    attrs: {
                        release: t.release,
                        environment: t.environment,
                        ip_address: t.ipAddress,
                        user_agent: t.userAgent
                    }
                })
            }(n)
        };
        return t && It(n, t),
        n
    }
    function It(t, e={}) {
        if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address),
        t.did || e.did || (t.did = e.user.id || e.user.email || e.user.username)),
        t.timestamp = e.timestamp || ht(),
        e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism),
        e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration),
        e.sid && (t.sid = 32 === e.sid.length ? e.sid : gt()),
        void 0 !== e.init && (t.init = e.init),
        !t.did && e.did && (t.did = `${e.did}`),
        "number" == typeof e.started && (t.started = e.started),
        t.ignoreDuration)
            t.duration = void 0;
        else if ("number" == typeof e.duration)
            t.duration = e.duration;
        else {
            const e = t.timestamp - t.started;
            t.duration = e >= 0 ? e : 0
        }
        e.release && (t.release = e.release),
        e.environment && (t.environment = e.environment),
        !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress),
        !t.userAgent && e.userAgent && (t.userAgent = e.userAgent),
        "number" == typeof e.errors && (t.errors = e.errors),
        e.status && (t.status = e.status)
    }
    function At() {
        return {
            traceId: gt(),
            spanId: gt().substring(16)
        }
    }
    function Ot(t, e, n=2) {
        if (!e || "object" != typeof e || n <= 0)
            return e;
        if (t && e && 0 === Object.keys(e).length)
            return t;
        const r = {
            ...t
        };
        for (const t in e)
            Object.prototype.hasOwnProperty.call(e, t) && (r[t] = Ot(r[t], e[t], n - 1));
        return r
    }
    const Pt = "_sentrySpan";
    function Ct(t, e) {
        e ? st(t, Pt, e) : delete t[Pt]
    }
    function $t(t) {
        return t[Pt]
    }
    class Dt {
        constructor() {
            this._notifyingListeners = !1,
            this._scopeListeners = [],
            this._eventProcessors = [],
            this._breadcrumbs = [],
            this._attachments = [],
            this._user = {},
            this._tags = {},
            this._extra = {},
            this._contexts = {},
            this._sdkProcessingMetadata = {},
            this._propagationContext = At()
        }
        clone() {
            const t = new Dt;
            return t._breadcrumbs = [...this._breadcrumbs],
            t._tags = {
                ...this._tags
            },
            t._extra = {
                ...this._extra
            },
            t._contexts = {
                ...this._contexts
            },
            t._user = this._user,
            t._level = this._level,
            t._session = this._session,
            t._transactionName = this._transactionName,
            t._fingerprint = this._fingerprint,
            t._eventProcessors = [...this._eventProcessors],
            t._requestSession = this._requestSession,
            t._attachments = [...this._attachments],
            t._sdkProcessingMetadata = {
                ...this._sdkProcessingMetadata
            },
            t._propagationContext = {
                ...this._propagationContext
            },
            t._client = this._client,
            t._lastEventId = this._lastEventId,
            Ct(t, $t(this)),
            t
        }
        setClient(t) {
            this._client = t
        }
        setLastEventId(t) {
            this._lastEventId = t
        }
        getClient() {
            return this._client
        }
        lastEventId() {
            return this._lastEventId
        }
        addScopeListener(t) {
            this._scopeListeners.push(t)
        }
        addEventProcessor(t) {
            return this._eventProcessors.push(t),
            this
        }
        setUser(t) {
            return this._user = t || {
                email: void 0,
                id: void 0,
                ip_address: void 0,
                username: void 0
            },
            this._session && It(this._session, {
                user: t
            }),
            this._notifyScopeListeners(),
            this
        }
        getUser() {
            return this._user
        }
        getRequestSession() {
            return this._requestSession
        }
        setRequestSession(t) {
            return this._requestSession = t,
            this
        }
        setTags(t) {
            return this._tags = {
                ...this._tags,
                ...t
            },
            this._notifyScopeListeners(),
            this
        }
        setTag(t, e) {
            return this._tags = {
                ...this._tags,
                [t]: e
            },
            this._notifyScopeListeners(),
            this
        }
        setExtras(t) {
            return this._extra = {
                ...this._extra,
                ...t
            },
            this._notifyScopeListeners(),
            this
        }
        setExtra(t, e) {
            return this._extra = {
                ...this._extra,
                [t]: e
            },
            this._notifyScopeListeners(),
            this
        }
        setFingerprint(t) {
            return this._fingerprint = t,
            this._notifyScopeListeners(),
            this
        }
        setLevel(t) {
            return this._level = t,
            this._notifyScopeListeners(),
            this
        }
        setTransactionName(t) {
            return this._transactionName = t,
            this._notifyScopeListeners(),
            this
        }
        setContext(t, e) {
            return null === e ? delete this._contexts[t] : this._contexts[t] = e,
            this._notifyScopeListeners(),
            this
        }
        setSession(t) {
            return t ? this._session = t : delete this._session,
            this._notifyScopeListeners(),
            this
        }
        getSession() {
            return this._session
        }
        update(t) {
            if (!t)
                return this;
            const e = "function" == typeof t ? t(this) : t
              , [n,r] = e instanceof Rt ? [e.getScopeData(), e.getRequestSession()] : z(e) ? [t, t.requestSession] : []
              , {tags: o, extra: s, user: i, contexts: a, level: c, fingerprint: u=[], propagationContext: d} = n || {};
            return this._tags = {
                ...this._tags,
                ...o
            },
            this._extra = {
                ...this._extra,
                ...s
            },
            this._contexts = {
                ...this._contexts,
                ...a
            },
            i && Object.keys(i).length && (this._user = i),
            c && (this._level = c),
            u.length && (this._fingerprint = u),
            d && (this._propagationContext = d),
            r && (this._requestSession = r),
            this
        }
        clear() {
            return this._breadcrumbs = [],
            this._tags = {},
            this._extra = {},
            this._user = {},
            this._contexts = {},
            this._level = void 0,
            this._transactionName = void 0,
            this._fingerprint = void 0,
            this._requestSession = void 0,
            this._session = void 0,
            Ct(this, void 0),
            this._attachments = [],
            this._propagationContext = At(),
            this._notifyScopeListeners(),
            this
        }
        addBreadcrumb(t, e) {
            const n = "number" == typeof e ? e : 100;
            if (n <= 0)
                return this;
            const r = {
                timestamp: ft(),
                ...t
            }
              , o = this._breadcrumbs;
            return o.push(r),
            this._breadcrumbs = o.length > n ? o.slice(-n) : o,
            this._notifyScopeListeners(),
            this
        }
        getLastBreadcrumb() {
            return this._breadcrumbs[this._breadcrumbs.length - 1]
        }
        clearBreadcrumbs() {
            return this._breadcrumbs = [],
            this._notifyScopeListeners(),
            this
        }
        addAttachment(t) {
            return this._attachments.push(t),
            this
        }
        clearAttachments() {
            return this._attachments = [],
            this
        }
        getScopeData() {
            return {
                breadcrumbs: this._breadcrumbs,
                attachments: this._attachments,
                contexts: this._contexts,
                tags: this._tags,
                extra: this._extra,
                user: this._user,
                level: this._level,
                fingerprint: this._fingerprint || [],
                eventProcessors: this._eventProcessors,
                propagationContext: this._propagationContext,
                sdkProcessingMetadata: this._sdkProcessingMetadata,
                transactionName: this._transactionName,
                span: $t(this)
            }
        }
        setSDKProcessingMetadata(t) {
            return this._sdkProcessingMetadata = Ot(this._sdkProcessingMetadata, t, 2),
            this
        }
        setPropagationContext(t) {
            return this._propagationContext = t,
            this
        }
        getPropagationContext() {
            return this._propagationContext
        }
        captureException(t, e) {
            const n = e && e.event_id ? e.event_id : gt();
            if (!this._client)
                return m.warn("No client configured on scope - will not capture exception!"),
                n;
            const r = new Error("Sentry syntheticException");
            return this._client.captureException(t, {
                originalException: t,
                syntheticException: r,
                ...e,
                event_id: n
            }, this),
            n
        }
        captureMessage(t, e, n) {
            const r = n && n.event_id ? n.event_id : gt();
            if (!this._client)
                return m.warn("No client configured on scope - will not capture message!"),
                r;
            const o = new Error(t);
            return this._client.captureMessage(t, e, {
                originalException: t,
                syntheticException: o,
                ...n,
                event_id: r
            }, this),
            r
        }
        captureEvent(t, e) {
            const n = e && e.event_id ? e.event_id : gt();
            return this._client ? (this._client.captureEvent(t, {
                ...e,
                event_id: n
            }, this),
            n) : (m.warn("No client configured on scope - will not capture event!"),
            n)
        }
        _notifyScopeListeners() {
            this._notifyingListeners || (this._notifyingListeners = !0,
            this._scopeListeners.forEach((t => {
                t(this)
            }
            )),
            this._notifyingListeners = !1)
        }
    }
    const Rt = Dt;
    class Lt {
        constructor(t, e) {
            let n, r;
            n = t || new Rt,
            r = e || new Rt,
            this._stack = [{
                scope: n
            }],
            this._isolationScope = r
        }
        withScope(t) {
            const e = this._pushScope();
            let n;
            try {
                n = t(e)
            } catch (t) {
                throw this._popScope(),
                t
            }
            return W(n) ? n.then((t => (this._popScope(),
            t)), (t => {
                throw this._popScope(),
                t
            }
            )) : (this._popScope(),
            n)
        }
        getClient() {
            return this.getStackTop().client
        }
        getScope() {
            return this.getStackTop().scope
        }
        getIsolationScope() {
            return this._isolationScope
        }
        getStackTop() {
            return this._stack[this._stack.length - 1]
        }
        _pushScope() {
            const t = this.getScope().clone();
            return this._stack.push({
                client: this.getClient(),
                scope: t
            }),
            t
        }
        _popScope() {
            return !(this._stack.length <= 1) && !!this._stack.pop()
        }
    }
    function Nt() {
        const t = N(L());
        return t.stack = t.stack || new Lt(d("defaultCurrentScope", ( () => new Rt)),d("defaultIsolationScope", ( () => new Rt)))
    }
    function Mt(t) {
        return Nt().withScope(t)
    }
    function jt(t, e) {
        const n = Nt();
        return n.withScope(( () => (n.getStackTop().scope = t,
        e(t))))
    }
    function Ut(t) {
        return Nt().withScope(( () => t(Nt().getIsolationScope())))
    }
    function qt(t) {
        const e = N(t);
        return e.acs ? e.acs : {
            withIsolationScope: Ut,
            withScope: Mt,
            withSetScope: jt,
            withSetIsolationScope: (t, e) => Ut(e),
            getCurrentScope: () => Nt().getScope(),
            getIsolationScope: () => Nt().getIsolationScope()
        }
    }
    function Ft() {
        return qt(L()).getCurrentScope()
    }
    function Gt() {
        return qt(L()).getIsolationScope()
    }
    function Ht(...t) {
        const e = qt(L());
        if (2 === t.length) {
            const [n,r] = t;
            return n ? e.withSetScope(n, r) : e.withScope(r)
        }
        return e.withScope(t[0])
    }
    function Bt() {
        return Ft().getClient()
    }
    function zt(t) {
        const e = t._sentryMetrics;
        if (!e)
            return;
        const n = {};
        for (const [,[t,r]] of e) {
            (n[t] || (n[t] = [])).push(pt(r))
        }
        return n
    }
    const Vt = "sentry.source"
      , Wt = "sentry.sample_rate"
      , Yt = "sentry.op"
      , Xt = "sentry.origin"
      , Jt = "sentry.idle_span_finish_reason"
      , Kt = "sentry.measurement_unit"
      , Qt = "sentry.measurement_value"
      , Zt = "sentry.exclusive_time";
    function te(t, e) {
        t.setAttribute("http.response.status_code", e);
        const n = function(t) {
            if (t < 400 && t >= 100)
                return {
                    code: 1
                };
            if (t >= 400 && t < 500)
                switch (t) {
                case 401:
                    return {
                        code: 2,
                        message: "unauthenticated"
                    };
                case 403:
                    return {
                        code: 2,
                        message: "permission_denied"
                    };
                case 404:
                    return {
                        code: 2,
                        message: "not_found"
                    };
                case 409:
                    return {
                        code: 2,
                        message: "already_exists"
                    };
                case 413:
                    return {
                        code: 2,
                        message: "failed_precondition"
                    };
                case 429:
                    return {
                        code: 2,
                        message: "resource_exhausted"
                    };
                case 499:
                    return {
                        code: 2,
                        message: "cancelled"
                    };
                default:
                    return {
                        code: 2,
                        message: "invalid_argument"
                    }
                }
            if (t >= 500 && t < 600)
                switch (t) {
                case 501:
                    return {
                        code: 2,
                        message: "unimplemented"
                    };
                case 503:
                    return {
                        code: 2,
                        message: "unavailable"
                    };
                case 504:
                    return {
                        code: 2,
                        message: "deadline_exceeded"
                    };
                default:
                    return {
                        code: 2,
                        message: "internal_error"
                    }
                }
            return {
                code: 2,
                message: "unknown_error"
            }
        }(e);
        "unknown_error" !== n.message && t.setStatus(n)
    }
    const ee = "baggage"
      , ne = "sentry-"
      , re = /^sentry-/;
    function oe(t) {
        const e = function(t) {
            if (!t || !G(t) && !Array.isArray(t))
                return;
            if (Array.isArray(t))
                return t.reduce(( (t, e) => {
                    const n = ie(e);
                    return Object.entries(n).forEach(( ([e,n]) => {
                        t[e] = n
                    }
                    )),
                    t
                }
                ), {});
            return ie(t)
        }(t);
        if (!e)
            return;
        const n = Object.entries(e).reduce(( (t, [e,n]) => {
            if (e.match(re)) {
                t[e.slice(7)] = n
            }
            return t
        }
        ), {});
        return Object.keys(n).length > 0 ? n : void 0
    }
    function se(t) {
        if (!t)
            return;
        return function(t) {
            if (0 === Object.keys(t).length)
                return;
            return Object.entries(t).reduce(( (t, [e,n], r) => {
                const o = `${encodeURIComponent(e)}=${encodeURIComponent(n)}`
                  , s = 0 === r ? o : `${t},${o}`;
                return s.length > 8192 ? (p && m.warn(`Not adding key: ${e} with val: ${n} to baggage header due to exceeding baggage size limits.`),
                t) : s
            }
            ), "")
        }(Object.entries(t).reduce(( (t, [e,n]) => (n && (t[`${ne}${e}`] = n),
        t)), {}))
    }
    function ie(t) {
        return t.split(",").map((t => t.split("=").map((t => decodeURIComponent(t.trim()))))).reduce(( (t, [e,n]) => (e && n && (t[e] = n),
        t)), {})
    }
    const ae = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
    function ce(t, e) {
        const n = function(t) {
            if (!t)
                return;
            const e = t.match(ae);
            if (!e)
                return;
            let n;
            return "1" === e[3] ? n = !0 : "0" === e[3] && (n = !1),
            {
                traceId: e[1],
                parentSampled: n,
                parentSpanId: e[2]
            }
        }(t)
          , r = oe(e)
          , {traceId: o, parentSpanId: s, parentSampled: i} = n || {};
        return n ? {
            traceId: o || gt(),
            parentSpanId: s || gt().substring(16),
            spanId: gt().substring(16),
            sampled: i,
            dsc: r || {}
        } : {
            traceId: o || gt(),
            spanId: gt().substring(16)
        }
    }
    function ue(t=gt(), e=gt().substring(16), n) {
        let r = "";
        return void 0 !== n && (r = n ? "-1" : "-0"),
        `${t}-${e}${r}`
    }
    function de(t) {
        const {spanId: e, traceId: n} = t.spanContext()
          , {data: r, op: o, parent_span_id: s, status: i, origin: a} = me(t);
        return pt({
            parent_span_id: s,
            span_id: e,
            trace_id: n,
            data: r,
            op: o,
            status: i,
            origin: a
        })
    }
    function pe(t) {
        const {spanId: e, traceId: n} = t.spanContext()
          , {parent_span_id: r} = me(t);
        return pt({
            parent_span_id: r,
            span_id: e,
            trace_id: n
        })
    }
    function le(t) {
        const {traceId: e, spanId: n} = t.spanContext();
        return ue(e, n, ge(t))
    }
    function fe(t) {
        return "number" == typeof t ? he(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? he(t.getTime()) : ht()
    }
    function he(t) {
        return t > 9999999999 ? t / 1e3 : t
    }
    function me(t) {
        if (function(t) {
            return "function" == typeof t.getSpanJSON
        }(t))
            return t.getSpanJSON();
        try {
            const {spanId: e, traceId: n} = t.spanContext();
            if (function(t) {
                const e = t;
                return !!(e.attributes && e.startTime && e.name && e.endTime && e.status)
            }(t)) {
                const {attributes: r, startTime: o, name: s, endTime: i, parentSpanId: a, status: c} = t;
                return pt({
                    span_id: e,
                    trace_id: n,
                    data: r,
                    description: s,
                    parent_span_id: a,
                    start_timestamp: fe(o),
                    timestamp: fe(i) || void 0,
                    status: _e(c),
                    op: r[Yt],
                    origin: r[Xt],
                    _metrics_summary: zt(t)
                })
            }
            return {
                span_id: e,
                trace_id: n
            }
        } catch (t) {
            return {}
        }
    }
    function ge(t) {
        const {traceFlags: e} = t.spanContext();
        return 1 === e
    }
    function _e(t) {
        if (t && 0 !== t.code)
            return 1 === t.code ? "ok" : t.message || "unknown_error"
    }
    const ve = "_sentryChildSpans"
      , ye = "_sentryRootSpan";
    function be(t, e) {
        const n = t[ye] || t;
        st(e, ye, n),
        t[ve] ? t[ve].add(e) : st(t, ve, new Set([e]))
    }
    function Se(t) {
        const e = new Set;
        return function t(n) {
            if (!e.has(n) && ge(n)) {
                e.add(n);
                const r = n[ve] ? Array.from(n[ve]) : [];
                for (const e of r)
                    t(e)
            }
        }(t),
        Array.from(e)
    }
    function Ee(t) {
        return t[ye] || t
    }
    function we() {
        const t = qt(L());
        return t.getActiveSpan ? t.getActiveSpan() : $t(Ft())
    }
    let Te = !1;
    function xe() {
        const t = we()
          , e = t && Ee(t);
        if (e) {
            const t = "internal_error";
            a && m.log(`[Tracing] Root span: ${t} -> Global error occurred`),
            e.setStatus({
                code: 2,
                message: t
            })
        }
    }
    xe.tag = "sentry_tracingErrorCallback";
    const ke = "_sentryScope"
      , Ie = "_sentryIsolationScope";
    function Ae(t) {
        return {
            scope: t[ke],
            isolationScope: t[Ie]
        }
    }
    function Oe(t) {
        if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
            return !1;
        const e = Bt()
          , n = t || e && e.getOptions();
        return !!n && (n.enableTracing || "tracesSampleRate"in n || "tracesSampler"in n)
    }
    class Pe {
        constructor(t={}) {
            this._traceId = t.traceId || gt(),
            this._spanId = t.spanId || gt().substring(16)
        }
        spanContext() {
            return {
                spanId: this._spanId,
                traceId: this._traceId,
                traceFlags: 0
            }
        }
        end(t) {}
        setAttribute(t, e) {
            return this
        }
        setAttributes(t) {
            return this
        }
        setStatus(t) {
            return this
        }
        updateName(t) {
            return this
        }
        isRecording() {
            return !1
        }
        addEvent(t, e, n) {
            return this
        }
        addLink(t) {
            return this
        }
        addLinks(t) {
            return this
        }
        recordException(t, e) {}
    }
    const Ce = "production"
      , $e = "_frozenDsc";
    function De(t, e) {
        st(t, $e, e)
    }
    function Re(t, e) {
        const n = e.getOptions()
          , {publicKey: r} = e.getDsn() || {}
          , o = pt({
            environment: n.environment || Ce,
            release: n.release,
            public_key: r,
            trace_id: t
        });
        return e.emit("createDsc", o),
        o
    }
    function Le(t) {
        const e = Bt();
        if (!e)
            return {};
        const n = Re(me(t).trace_id || "", e)
          , r = Ee(t)
          , o = r[$e];
        if (o)
            return o;
        const s = r.spanContext().traceState
          , i = s && s.get("sentry.dsc")
          , a = i && oe(i);
        if (a)
            return a;
        const c = me(r)
          , u = c.data || {}
          , d = u[Wt];
        null != d && (n.sample_rate = `${d}`);
        const p = u[Vt]
          , l = c.description;
        return "url" !== p && l && (n.transaction = l),
        Oe() && (n.sampled = String(ge(r))),
        e.emit("createDsc", n, r),
        n
    }
    function Ne(t) {
        if ("boolean" == typeof t)
            return Number(t);
        const e = "string" == typeof t ? parseFloat(t) : t;
        if (!("number" != typeof e || isNaN(e) || e < 0 || e > 1))
            return e;
        a && m.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(t)} of type ${JSON.stringify(typeof t)}.`)
    }
    const Me = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function je(t, e=!1) {
        const {host: n, path: r, pass: o, port: s, projectId: i, protocol: a, publicKey: c} = t;
        return `${a}://${c}${e && o ? `:${o}` : ""}@${n}${s ? `:${s}` : ""}/${r ? `${r}/` : r}${i}`
    }
    function Ue(t) {
        return {
            protocol: t.protocol,
            publicKey: t.publicKey || "",
            pass: t.pass || "",
            host: t.host,
            port: t.port || "",
            path: t.path || "",
            projectId: t.projectId
        }
    }
    function qe(t) {
        const e = "string" == typeof t ? function(t) {
            const e = Me.exec(t);
            if (!e)
                return void h(( () => {
                    console.error(`Invalid Sentry Dsn: ${t}`)
                }
                ));
            const [n,r,o="",s="",i="",a=""] = e.slice(1);
            let c = ""
              , u = a;
            const d = u.split("/");
            if (d.length > 1 && (c = d.slice(0, -1).join("/"),
            u = d.pop()),
            u) {
                const t = u.match(/^\d+/);
                t && (u = t[0])
            }
            return Ue({
                host: s,
                pass: o,
                path: c,
                projectId: u,
                port: i,
                protocol: n,
                publicKey: r
            })
        }(t) : Ue(t);
        if (e && function(t) {
            if (!p)
                return !0;
            const {port: e, projectId: n, protocol: r} = t;
            return !(["protocol", "publicKey", "host", "projectId"].find((e => !t[e] && (m.error(`Invalid Sentry Dsn: ${e} missing`),
            !0))) || (n.match(/^\d+$/) ? function(t) {
                return "http" === t || "https" === t
            }(r) ? e && isNaN(parseInt(e, 10)) && (m.error(`Invalid Sentry Dsn: Invalid port ${e}`),
            1) : (m.error(`Invalid Sentry Dsn: Invalid protocol ${r}`),
            1) : (m.error(`Invalid Sentry Dsn: Invalid projectId ${n}`),
            1)))
        }(e))
            return e
    }
    function Fe(t, e=100, n=1 / 0) {
        try {
            return He("", t, e, n)
        } catch (t) {
            return {
                ERROR: `**non-serializable** (${t})`
            }
        }
    }
    function Ge(t, e=3, n=102400) {
        const r = Fe(t, e);
        return o = r,
        function(t) {
            return ~-encodeURI(t).split(/%..|./).length
        }(JSON.stringify(o)) > n ? Ge(t, e - 1, n) : r;
        var o
    }
    function He(t, e, n=1 / 0, r=1 / 0, o=function() {
        const t = "function" == typeof WeakSet
          , e = t ? new WeakSet : [];
        return [function(n) {
            if (t)
                return !!e.has(n) || (e.add(n),
                !1);
            for (let t = 0; t < e.length; t++)
                if (e[t] === n)
                    return !0;
            return e.push(n),
            !1
        }
        , function(n) {
            if (t)
                e.delete(n);
            else
                for (let t = 0; t < e.length; t++)
                    if (e[t] === n) {
                        e.splice(t, 1);
                        break
                    }
        }
        ]
    }()) {
        const [s,i] = o;
        if (null == e || ["boolean", "string"].includes(typeof e) || "number" == typeof e && Number.isFinite(e))
            return e;
        const a = function(t, e) {
            try {
                if ("domain" === t && e && "object" == typeof e && e._events)
                    return "[Domain]";
                if ("domainEmitter" === t)
                    return "[DomainEmitter]";
                if ("undefined" != typeof global && e === global)
                    return "[Global]";
                if ("undefined" != typeof window && e === window)
                    return "[Window]";
                if ("undefined" != typeof document && e === document)
                    return "[Document]";
                if (X(e))
                    return "[VueViewModel]";
                if (z(n = e) && "nativeEvent"in n && "preventDefault"in n && "stopPropagation"in n)
                    return "[SyntheticEvent]";
                if ("number" == typeof e && !Number.isFinite(e))
                    return `[${e}]`;
                if ("function" == typeof e)
                    return `[Function: ${E(e)}]`;
                if ("symbol" == typeof e)
                    return `[${String(e)}]`;
                if ("bigint" == typeof e)
                    return `[BigInt: ${String(e)}]`;
                const r = function(t) {
                    const e = Object.getPrototypeOf(t);
                    return e ? e.constructor.name : "null prototype"
                }(e);
                return /^HTML(\w*)Element$/.test(r) ? `[HTMLElement: ${r}]` : `[object ${r}]`
            } catch (t) {
                return `**non-serializable** (${t})`
            }
            var n
        }(t, e);
        if (!a.startsWith("[object "))
            return a;
        if (e.__sentry_skip_normalization__)
            return e;
        const c = "number" == typeof e.__sentry_override_normalization_depth__ ? e.__sentry_override_normalization_depth__ : n;
        if (0 === c)
            return a.replace("object ", "");
        if (s(e))
            return "[Circular ~]";
        const u = e;
        if (u && "function" == typeof u.toJSON)
            try {
                return He("", u.toJSON(), c - 1, r, o)
            } catch (t) {}
        const d = Array.isArray(e) ? [] : {};
        let p = 0;
        const l = ct(e);
        for (const t in l) {
            if (!Object.prototype.hasOwnProperty.call(l, t))
                continue;
            if (p >= r) {
                d[t] = "[MaxProperties ~]";
                break
            }
            const e = l[t];
            d[t] = He(t, e, c - 1, r, o),
            p++
        }
        return i(e),
        d
    }
    function Be(t, e=[]) {
        return [t, e]
    }
    function ze(t, e) {
        const [n,r] = t;
        return [n, [...r, e]]
    }
    function Ve(t, e) {
        const n = t[1];
        for (const t of n) {
            if (e(t, t[0].type))
                return !0
        }
        return !1
    }
    function We(t) {
        return u.__SENTRY__ && u.__SENTRY__.encodePolyfill ? u.__SENTRY__.encodePolyfill(t) : (new TextEncoder).encode(t)
    }
    function Ye(t) {
        const [e,n] = t;
        let r = JSON.stringify(e);
        function o(t) {
            "string" == typeof r ? r = "string" == typeof t ? r + t : [We(r), t] : r.push("string" == typeof t ? We(t) : t)
        }
        for (const t of n) {
            const [e,n] = t;
            if (o(`\n${JSON.stringify(e)}\n`),
            "string" == typeof n || n instanceof Uint8Array)
                o(n);
            else {
                let t;
                try {
                    t = JSON.stringify(n)
                } catch (e) {
                    t = JSON.stringify(Fe(n))
                }
                o(t)
            }
        }
        return "string" == typeof r ? r : function(t) {
            const e = t.reduce(( (t, e) => t + e.length), 0)
              , n = new Uint8Array(e);
            let r = 0;
            for (const e of t)
                n.set(e, r),
                r += e.length;
            return n
        }(r)
    }
    function Xe(t) {
        return [{
            type: "span"
        }, t]
    }
    function Je(t) {
        const e = "string" == typeof t.data ? We(t.data) : t.data;
        return [pt({
            type: "attachment",
            length: e.length,
            filename: t.filename,
            content_type: t.contentType,
            attachment_type: t.attachmentType
        }), e]
    }
    const Ke = {
        session: "session",
        sessions: "session",
        attachment: "attachment",
        transaction: "transaction",
        event: "error",
        client_report: "internal",
        user_report: "default",
        profile: "profile",
        profile_chunk: "profile",
        replay_event: "replay",
        replay_recording: "replay",
        check_in: "monitor",
        feedback: "feedback",
        span: "span",
        statsd: "metric_bucket"
    };
    function Qe(t) {
        return Ke[t]
    }
    function Ze(t) {
        if (!t || !t.sdk)
            return;
        const {name: e, version: n} = t.sdk;
        return {
            name: e,
            version: n
        }
    }
    function tn(t, e, n, r) {
        const o = Ze(n)
          , s = t.type && "replay_event" !== t.type ? t.type : "event";
        !function(t, e) {
            e && (t.sdk = t.sdk || {},
            t.sdk.name = t.sdk.name || e.name,
            t.sdk.version = t.sdk.version || e.version,
            t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []],
            t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []])
        }(t, n && n.sdk);
        const i = function(t, e, n, r) {
            const o = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
            return {
                event_id: t.event_id,
                sent_at: (new Date).toISOString(),
                ...e && {
                    sdk: e
                },
                ...!!n && r && {
                    dsn: je(r)
                },
                ...o && {
                    trace: pt({
                        ...o
                    })
                }
            }
        }(t, o, r, e);
        delete t.sdkProcessingMetadata;
        return Be(i, [[{
            type: s
        }, t]])
    }
    function en(t) {
        if (!t || 0 === t.length)
            return;
        const e = {};
        return t.forEach((t => {
            const n = t.attributes || {}
              , r = n[Kt]
              , o = n[Qt];
            "string" == typeof r && "number" == typeof o && (e[t.name] = {
                value: o,
                unit: r
            })
        }
        )),
        e
    }
    class nn {
        constructor(t={}) {
            this._traceId = t.traceId || gt(),
            this._spanId = t.spanId || gt().substring(16),
            this._startTime = t.startTimestamp || ht(),
            this._attributes = {},
            this.setAttributes({
                [Xt]: "manual",
                [Yt]: t.op,
                ...t.attributes
            }),
            this._name = t.name,
            t.parentSpanId && (this._parentSpanId = t.parentSpanId),
            "sampled"in t && (this._sampled = t.sampled),
            t.endTimestamp && (this._endTime = t.endTimestamp),
            this._events = [],
            this._isStandaloneSpan = t.isStandalone,
            this._endTime && this._onSpanEnded()
        }
        addLink(t) {
            return this
        }
        addLinks(t) {
            return this
        }
        recordException(t, e) {}
        spanContext() {
            const {_spanId: t, _traceId: e, _sampled: n} = this;
            return {
                spanId: t,
                traceId: e,
                traceFlags: n ? 1 : 0
            }
        }
        setAttribute(t, e) {
            return void 0 === e ? delete this._attributes[t] : this._attributes[t] = e,
            this
        }
        setAttributes(t) {
            return Object.keys(t).forEach((e => this.setAttribute(e, t[e]))),
            this
        }
        updateStartTime(t) {
            this._startTime = fe(t)
        }
        setStatus(t) {
            return this._status = t,
            this
        }
        updateName(t) {
            return this._name = t,
            this.setAttribute(Vt, "custom"),
            this
        }
        end(t) {
            this._endTime || (this._endTime = fe(t),
            function(t) {
                if (!a)
                    return;
                const {description: e="< unknown name >", op: n="< unknown op >"} = me(t)
                  , {spanId: r} = t.spanContext()
                  , o = `[Tracing] Finishing "${n}" ${Ee(t) === t ? "root " : ""}span "${e}" with ID ${r}`;
                m.log(o)
            }(this),
            this._onSpanEnded())
        }
        getSpanJSON() {
            return pt({
                data: this._attributes,
                description: this._name,
                op: this._attributes[Yt],
                parent_span_id: this._parentSpanId,
                span_id: this._spanId,
                start_timestamp: this._startTime,
                status: _e(this._status),
                timestamp: this._endTime,
                trace_id: this._traceId,
                origin: this._attributes[Xt],
                _metrics_summary: zt(this),
                profile_id: this._attributes["sentry.profile_id"],
                exclusive_time: this._attributes[Zt],
                measurements: en(this._events),
                is_segment: this._isStandaloneSpan && Ee(this) === this || void 0,
                segment_id: this._isStandaloneSpan ? Ee(this).spanContext().spanId : void 0
            })
        }
        isRecording() {
            return !this._endTime && !!this._sampled
        }
        addEvent(t, e, n) {
            a && m.log("[Tracing] Adding an event to span:", t);
            const r = rn(e) ? e : n || ht()
              , o = rn(e) ? {} : e || {}
              , s = {
                name: t,
                time: fe(r),
                attributes: o
            };
            return this._events.push(s),
            this
        }
        isStandaloneSpan() {
            return !!this._isStandaloneSpan
        }
        _onSpanEnded() {
            const t = Bt();
            t && t.emit("spanEnd", this);
            if (!(this._isStandaloneSpan || this === Ee(this)))
                return;
            if (this._isStandaloneSpan)
                return void (this._sampled ? function(t) {
                    const e = Bt();
                    if (!e)
                        return;
                    const n = t[1];
                    if (!n || 0 === n.length)
                        return void e.recordDroppedEvent("before_send", "span");
                    e.sendEnvelope(t)
                }(function(t, e) {
                    const n = Le(t[0])
                      , r = e && e.getDsn()
                      , o = e && e.getOptions().tunnel
                      , s = {
                        sent_at: (new Date).toISOString(),
                        ...function(t) {
                            return !!t.trace_id && !!t.public_key
                        }(n) && {
                            trace: n
                        },
                        ...!!o && r && {
                            dsn: je(r)
                        }
                    }
                      , i = e && e.getOptions().beforeSendSpan
                      , a = i ? t => i(me(t)) : t => me(t)
                      , c = [];
                    for (const e of t) {
                        const t = a(e);
                        t && c.push(Xe(t))
                    }
                    return Be(s, c)
                }([this], t)) : (a && m.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),
                t && t.recordDroppedEvent("sample_rate", "span")));
            const e = this._convertSpanToTransaction();
            if (e) {
                (Ae(this).scope || Ft()).captureEvent(e)
            }
        }
        _convertSpanToTransaction() {
            if (!on(me(this)))
                return;
            this._name || (a && m.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),
            this._name = "<unlabeled transaction>");
            const {scope: t, isolationScope: e} = Ae(this)
              , n = (t || Ft()).getClient() || Bt();
            if (!0 !== this._sampled)
                return a && m.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."),
                void (n && n.recordDroppedEvent("sample_rate", "transaction"));
            const r = Se(this).filter((t => t !== this && !function(t) {
                return t instanceof nn && t.isStandaloneSpan()
            }(t))).map((t => me(t))).filter(on)
              , o = this._attributes[Vt]
              , s = {
                contexts: {
                    trace: de(this)
                },
                spans: r.length > 1e3 ? r.sort(( (t, e) => t.start_timestamp - e.start_timestamp)).slice(0, 1e3) : r,
                start_timestamp: this._startTime,
                timestamp: this._endTime,
                transaction: this._name,
                type: "transaction",
                sdkProcessingMetadata: {
                    capturedSpanScope: t,
                    capturedSpanIsolationScope: e,
                    ...pt({
                        dynamicSamplingContext: Le(this)
                    })
                },
                _metrics_summary: zt(this),
                ...o && {
                    transaction_info: {
                        source: o
                    }
                }
            }
              , i = en(this._events);
            return i && Object.keys(i).length && (a && m.log("[Measurements] Adding measurements to transaction event", JSON.stringify(i, void 0, 2)),
            s.measurements = i),
            s
        }
    }
    function rn(t) {
        return t && "number" == typeof t || t instanceof Date || Array.isArray(t)
    }
    function on(t) {
        return !!(t.start_timestamp && t.timestamp && t.span_id && t.trace_id)
    }
    const sn = "__SENTRY_SUPPRESS_TRACING__";
    function an(t) {
        const e = un();
        if (e.startInactiveSpan)
            return e.startInactiveSpan(t);
        const n = function(t) {
            const e = t.experimental || {}
              , n = {
                isStandalone: e.standalone,
                ...t
            };
            if (t.startTime) {
                const e = {
                    ...n
                };
                return e.startTimestamp = fe(t.startTime),
                delete e.startTime,
                e
            }
            return n
        }(t)
          , {forceTransaction: r, parentSpan: o} = t;
        return (t.scope ? e => Ht(t.scope, e) : void 0 !== o ? t => cn(o, t) : t => t())(( () => {
            const e = Ft()
              , o = function(t) {
                const e = $t(t);
                if (!e)
                    return;
                const n = Bt()
                  , r = n ? n.getOptions() : {};
                if (r.parentSpanIsAlwaysRootSpan)
                    return Ee(e);
                return e
            }(e);
            return t.onlyIfParent && !o ? new Pe : function({parentSpan: t, spanArguments: e, forceTransaction: n, scope: r}) {
                if (!Oe())
                    return new Pe;
                const o = Gt();
                let s;
                if (t && !n)
                    s = function(t, e, n) {
                        const {spanId: r, traceId: o} = t.spanContext()
                          , s = !e.getScopeData().sdkProcessingMetadata[sn] && ge(t)
                          , i = s ? new nn({
                            ...n,
                            parentSpanId: r,
                            traceId: o,
                            sampled: s
                        }) : new Pe({
                            traceId: o
                        });
                        be(t, i);
                        const a = Bt();
                        a && (a.emit("spanStart", i),
                        n.endTimestamp && a.emit("spanEnd", i));
                        return i
                    }(t, r, e),
                    be(t, s);
                else if (t) {
                    const n = Le(t)
                      , {traceId: o, spanId: i} = t.spanContext()
                      , a = ge(t);
                    s = dn({
                        traceId: o,
                        parentSpanId: i,
                        ...e
                    }, r, a),
                    De(s, n)
                } else {
                    const {traceId: t, dsc: n, parentSpanId: i, sampled: a} = {
                        ...o.getPropagationContext(),
                        ...r.getPropagationContext()
                    };
                    s = dn({
                        traceId: t,
                        parentSpanId: i,
                        ...e
                    }, r, a),
                    n && De(s, n)
                }
                return function(t) {
                    if (!a)
                        return;
                    const {description: e="< unknown name >", op: n="< unknown op >", parent_span_id: r} = me(t)
                      , {spanId: o} = t.spanContext()
                      , s = ge(t)
                      , i = Ee(t)
                      , c = i === t
                      , u = `[Tracing] Starting ${s ? "sampled" : "unsampled"} ${c ? "root " : ""}span`
                      , d = [`op: ${n}`, `name: ${e}`, `ID: ${o}`];
                    if (r && d.push(`parent ID: ${r}`),
                    !c) {
                        const {op: t, description: e} = me(i);
                        d.push(`root ID: ${i.spanContext().spanId}`),
                        t && d.push(`root op: ${t}`),
                        e && d.push(`root description: ${e}`)
                    }
                    m.log(`${u}\n  ${d.join("\n  ")}`)
                }(s),
                function(t, e, n) {
                    t && (st(t, Ie, n),
                    st(t, ke, e))
                }(s, r, o),
                s
            }({
                parentSpan: o,
                spanArguments: n,
                forceTransaction: r,
                scope: e
            })
        }
        ))
    }
    function cn(t, e) {
        const n = un();
        return n.withActiveSpan ? n.withActiveSpan(t, e) : Ht((n => (Ct(n, t || void 0),
        e(n))))
    }
    function un() {
        return qt(L())
    }
    function dn(t, e, n) {
        const r = Bt()
          , o = r && r.getOptions() || {}
          , {name: s="", attributes: i} = t
          , [c,u] = e.getScopeData().sdkProcessingMetadata[sn] ? [!1] : function(t, e) {
            if (!Oe(t))
                return [!1];
            let n;
            n = "function" == typeof t.tracesSampler ? t.tracesSampler(e) : void 0 !== e.parentSampled ? e.parentSampled : void 0 !== t.tracesSampleRate ? t.tracesSampleRate : 1;
            const r = Ne(n);
            return void 0 === r ? (a && m.warn("[Tracing] Discarding transaction because of invalid sample rate."),
            [!1]) : r ? Math.random() < r ? [!0, r] : (a && m.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(n)})`),
            [!1, r]) : (a && m.log("[Tracing] Discarding transaction because " + ("function" == typeof t.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")),
            [!1, r])
        }(o, {
            name: s,
            parentSampled: n,
            attributes: i,
            transactionContext: {
                name: s,
                parentSampled: n
            }
        })
          , d = new nn({
            ...t,
            attributes: {
                [Vt]: "custom",
                ...t.attributes
            },
            sampled: c
        });
        return void 0 !== u && d.setAttribute(Wt, u),
        r && r.emit("spanStart", d),
        d
    }
    const pn = {
        idleTimeout: 1e3,
        finalTimeout: 3e4,
        childSpanTimeout: 15e3
    };
    function ln(t, e={}) {
        const n = new Map;
        let r, o = !1, s = "externalFinish", i = !e.disableAutoFinish;
        const c = []
          , {idleTimeout: u=pn.idleTimeout, finalTimeout: d=pn.finalTimeout, childSpanTimeout: p=pn.childSpanTimeout, beforeSpanEnd: l} = e
          , f = Bt();
        if (!f || !Oe())
            return new Pe;
        const h = Ft()
          , g = we()
          , _ = function(t) {
            const e = an(t);
            return Ct(Ft(), e),
            a && m.log("[Tracing] Started span is an idle span"),
            e
        }(t);
        function v() {
            r && (clearTimeout(r),
            r = void 0)
        }
        function y(t) {
            v(),
            r = setTimeout(( () => {
                !o && 0 === n.size && i && (s = "idleTimeout",
                _.end(t))
            }
            ), u)
        }
        function b(t) {
            r = setTimeout(( () => {
                !o && i && (s = "heartbeatFailed",
                _.end(t))
            }
            ), p)
        }
        function S(t) {
            o = !0,
            n.clear(),
            c.forEach((t => t())),
            Ct(h, g);
            const e = me(_)
              , {start_timestamp: r} = e;
            if (!r)
                return;
            (e.data || {})[Jt] || _.setAttribute(Jt, s),
            m.log(`[Tracing] Idle span "${e.op}" finished`);
            const i = Se(_).filter((t => t !== _));
            let p = 0;
            i.forEach((e => {
                e.isRecording() && (e.setStatus({
                    code: 2,
                    message: "cancelled"
                }),
                e.end(t),
                a && m.log("[Tracing] Cancelling span since span ended early", JSON.stringify(e, void 0, 2)));
                const n = me(e)
                  , {timestamp: r=0, start_timestamp: o=0} = n
                  , s = o <= t
                  , i = r - o <= (d + u) / 1e3;
                if (a) {
                    const t = JSON.stringify(e, void 0, 2);
                    s ? i || m.log("[Tracing] Discarding span since it finished after idle span final timeout", t) : m.log("[Tracing] Discarding span since it happened after idle span was finished", t)
                }
                i && s || (!function(t, e) {
                    t[ve] && t[ve].delete(e)
                }(_, e),
                p++)
            }
            )),
            p > 0 && _.setAttribute("sentry.idle_span_discarded_spans", p)
        }
        return _.end = new Proxy(_.end,{
            apply(t, e, n) {
                l && l(_);
                const [r,...o] = n
                  , s = fe(r || ht())
                  , i = Se(_).filter((t => t !== _));
                if (!i.length)
                    return S(s),
                    Reflect.apply(t, e, [s, ...o]);
                const a = i.map((t => me(t).timestamp)).filter((t => !!t))
                  , c = a.length ? Math.max(...a) : void 0
                  , u = me(_).start_timestamp
                  , p = Math.min(u ? u + d / 1e3 : 1 / 0, Math.max(u || -1 / 0, Math.min(s, c || 1 / 0)));
                return S(p),
                Reflect.apply(t, e, [p, ...o])
            }
        }),
        c.push(f.on("spanStart", (t => {
            if (o || t === _ || me(t).timestamp)
                return;
            var e;
            Se(_).includes(t) && (e = t.spanContext().spanId,
            v(),
            n.set(e, !0),
            b(ht() + p / 1e3))
        }
        ))),
        c.push(f.on("spanEnd", (t => {
            var e;
            o || (e = t.spanContext().spanId,
            n.has(e) && n.delete(e),
            0 === n.size && y(ht() + u / 1e3))
        }
        ))),
        c.push(f.on("idleSpanEnableAutoFinish", (t => {
            t === _ && (i = !0,
            y(),
            n.size && b())
        }
        ))),
        e.disableAutoFinish || y(),
        setTimeout(( () => {
            o || (_.setStatus({
                code: 2,
                message: "deadline_exceeded"
            }),
            s = "finalTimeout",
            _.end())
        }
        ), d),
        _
    }
    function fn(t, e, n, r=0) {
        return new xt(( (o, s) => {
            const i = t[r];
            if (null === e || "function" != typeof i)
                o(e);
            else {
                const c = i({
                    ...e
                }, n);
                a && i.id && null === c && m.log(`Event processor "${i.id}" dropped event`),
                W(c) ? c.then((e => fn(t, e, n, r + 1).then(o))).then(null, s) : fn(t, c, n, r + 1).then(o).then(null, s)
            }
        }
        ))
    }
    const hn = new WeakMap;
    function mn(t, e) {
        const {fingerprint: n, span: r, breadcrumbs: o, sdkProcessingMetadata: s} = e;
        !function(t, e) {
            const {extra: n, tags: r, user: o, contexts: s, level: i, transactionName: a} = e
              , c = pt(n);
            c && Object.keys(c).length && (t.extra = {
                ...c,
                ...t.extra
            });
            const u = pt(r);
            u && Object.keys(u).length && (t.tags = {
                ...u,
                ...t.tags
            });
            const d = pt(o);
            d && Object.keys(d).length && (t.user = {
                ...d,
                ...t.user
            });
            const p = pt(s);
            p && Object.keys(p).length && (t.contexts = {
                ...p,
                ...t.contexts
            });
            i && (t.level = i);
            a && "transaction" !== t.type && (t.transaction = a)
        }(t, e),
        r && function(t, e) {
            t.contexts = {
                trace: pe(e),
                ...t.contexts
            },
            t.sdkProcessingMetadata = {
                dynamicSamplingContext: Le(e),
                ...t.sdkProcessingMetadata
            };
            const n = Ee(e)
              , r = me(n).description;
            r && !t.transaction && "transaction" === t.type && (t.transaction = r)
        }(t, r),
        function(t, e) {
            t.fingerprint = t.fingerprint ? Array.isArray(t.fingerprint) ? t.fingerprint : [t.fingerprint] : [],
            e && (t.fingerprint = t.fingerprint.concat(e));
            t.fingerprint && !t.fingerprint.length && delete t.fingerprint
        }(t, n),
        function(t, e) {
            const n = [...t.breadcrumbs || [], ...e];
            t.breadcrumbs = n.length ? n : void 0
        }(t, o),
        function(t, e) {
            t.sdkProcessingMetadata = {
                ...t.sdkProcessingMetadata,
                ...e
            }
        }(t, s)
    }
    function gn(t, e) {
        const {extra: n, tags: r, user: o, contexts: s, level: i, sdkProcessingMetadata: a, breadcrumbs: c, fingerprint: u, eventProcessors: d, attachments: p, propagationContext: l, transactionName: f, span: h} = e;
        _n(t, "extra", n),
        _n(t, "tags", r),
        _n(t, "user", o),
        _n(t, "contexts", s),
        t.sdkProcessingMetadata = Ot(t.sdkProcessingMetadata, a, 2),
        i && (t.level = i),
        f && (t.transactionName = f),
        h && (t.span = h),
        c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]),
        u.length && (t.fingerprint = [...t.fingerprint, ...u]),
        d.length && (t.eventProcessors = [...t.eventProcessors, ...d]),
        p.length && (t.attachments = [...t.attachments, ...p]),
        t.propagationContext = {
            ...t.propagationContext,
            ...l
        }
    }
    function _n(t, e, n) {
        t[e] = Ot(t[e], n, 1)
    }
    function vn(t, e, n, r, o, s) {
        const {normalizeDepth: i=3, normalizeMaxBreadth: a=1e3} = t
          , c = {
            ...e,
            event_id: e.event_id || n.event_id || gt(),
            timestamp: e.timestamp || ft()
        }
          , p = n.integrations || t.integrations.map((t => t.name));
        !function(t, e) {
            const {environment: n, release: r, dist: o, maxValueLength: s=250} = e;
            "environment"in t || (t.environment = "environment"in e ? n : Ce);
            void 0 === t.release && void 0 !== r && (t.release = r);
            void 0 === t.dist && void 0 !== o && (t.dist = o);
            t.message && (t.message = tt(t.message, s));
            const i = t.exception && t.exception.values && t.exception.values[0];
            i && i.value && (i.value = tt(i.value, s));
            const a = t.request;
            a && a.url && (a.url = tt(a.url, s))
        }(c, t),
        function(t, e) {
            e.length > 0 && (t.sdk = t.sdk || {},
            t.sdk.integrations = [...t.sdk.integrations || [], ...e])
        }(c, p),
        o && o.emit("applyFrameMetadata", e),
        void 0 === e.type && function(t, e) {
            const n = function(t) {
                const e = u._sentryDebugIds;
                if (!e)
                    return {};
                let n;
                const r = hn.get(t);
                return r ? n = r : (n = new Map,
                hn.set(t, n)),
                Object.keys(e).reduce(( (r, o) => {
                    let s;
                    const i = n.get(o);
                    i ? s = i : (s = t(o),
                    n.set(o, s));
                    for (let t = s.length - 1; t >= 0; t--) {
                        const n = s[t]
                          , i = n && n.filename;
                        if (n && i) {
                            r[i] = e[o];
                            break
                        }
                    }
                    return r
                }
                ), {})
            }(e);
            try {
                t.exception.values.forEach((t => {
                    t.stacktrace.frames.forEach((t => {
                        t.filename && (t.debug_id = n[t.filename])
                    }
                    ))
                }
                ))
            } catch (t) {}
        }(c, t.stackParser);
        const l = function(t, e) {
            if (!e)
                return t;
            const n = t ? t.clone() : new Rt;
            return n.update(e),
            n
        }(r, n.captureContext);
        n.mechanism && bt(c, n.mechanism);
        const f = o ? o.getEventProcessors() : []
          , h = d("globalScope", ( () => new Rt)).getScopeData();
        if (s) {
            gn(h, s.getScopeData())
        }
        if (l) {
            gn(h, l.getScopeData())
        }
        const m = [...n.attachments || [], ...h.attachments];
        m.length && (n.attachments = m),
        mn(c, h);
        return fn([...f, ...h.eventProcessors], c, n).then((t => (t && function(t) {
            const e = {};
            try {
                t.exception.values.forEach((t => {
                    t.stacktrace.frames.forEach((t => {
                        t.debug_id && (t.abs_path ? e[t.abs_path] = t.debug_id : t.filename && (e[t.filename] = t.debug_id),
                        delete t.debug_id)
                    }
                    ))
                }
                ))
            } catch (t) {}
            if (0 === Object.keys(e).length)
                return;
            t.debug_meta = t.debug_meta || {},
            t.debug_meta.images = t.debug_meta.images || [];
            const n = t.debug_meta.images;
            Object.entries(e).forEach(( ([t,e]) => {
                n.push({
                    type: "sourcemap",
                    code_file: t,
                    debug_id: e
                })
            }
            ))
        }(t),
        "number" == typeof i && i > 0 ? function(t, e, n) {
            if (!t)
                return null;
            const r = {
                ...t,
                ...t.breadcrumbs && {
                    breadcrumbs: t.breadcrumbs.map((t => ({
                        ...t,
                        ...t.data && {
                            data: Fe(t.data, e, n)
                        }
                    })))
                },
                ...t.user && {
                    user: Fe(t.user, e, n)
                },
                ...t.contexts && {
                    contexts: Fe(t.contexts, e, n)
                },
                ...t.extra && {
                    extra: Fe(t.extra, e, n)
                }
            };
            t.contexts && t.contexts.trace && r.contexts && (r.contexts.trace = t.contexts.trace,
            t.contexts.trace.data && (r.contexts.trace.data = Fe(t.contexts.trace.data, e, n)));
            t.spans && (r.spans = t.spans.map((t => ({
                ...t,
                ...t.data && {
                    data: Fe(t.data, e, n)
                }
            }))));
            return r
        }(t, i, a) : t)))
    }
    function yn(t, e) {
        return Ft().captureException(t, void 0)
    }
    function bn(t, e) {
        return Ft().captureEvent(t, e)
    }
    function Sn(t) {
        const e = Bt()
          , n = Gt()
          , r = Ft()
          , {release: o, environment: s=Ce} = e && e.getOptions() || {}
          , {userAgent: i} = u.navigator || {}
          , a = kt({
            release: o,
            environment: s,
            user: r.getUser() || n.getUser(),
            ...i && {
                userAgent: i
            },
            ...t
        })
          , c = n.getSession();
        return c && "ok" === c.status && It(c, {
            status: "exited"
        }),
        En(),
        n.setSession(a),
        r.setSession(a),
        a
    }
    function En() {
        const t = Gt()
          , e = Ft()
          , n = e.getSession() || t.getSession();
        n && function(t) {
            let e = {};
            "ok" === t.status && (e = {
                status: "exited"
            }),
            It(t, e)
        }(n),
        wn(),
        t.setSession(),
        e.setSession()
    }
    function wn() {
        const t = Gt()
          , e = Ft()
          , n = Bt()
          , r = e.getSession() || t.getSession();
        r && n && n.captureSession(r)
    }
    function Tn(t=!1) {
        t ? En() : wn()
    }
    function xn(t, e) {
        return n = {
            sentry_key: t.publicKey,
            sentry_version: "7",
            ...e && {
                sentry_client: `${e.name}/${e.version}`
            }
        },
        Object.keys(n).map((t => `${encodeURIComponent(t)}=${encodeURIComponent(n[t])}`)).join("&");
        var n
    }
    const kn = [];
    function In(t) {
        const e = t.defaultIntegrations || []
          , n = t.integrations;
        let r;
        if (e.forEach((t => {
            t.isDefaultInstance = !0
        }
        )),
        Array.isArray(n))
            r = [...e, ...n];
        else if ("function" == typeof n) {
            const t = n(e);
            r = Array.isArray(t) ? t : [t]
        } else
            r = e;
        const o = function(t) {
            const e = {};
            return t.forEach((t => {
                const {name: n} = t
                  , r = e[n];
                r && !r.isDefaultInstance && t.isDefaultInstance || (e[n] = t)
            }
            )),
            Object.values(e)
        }(r)
          , s = o.findIndex((t => "Debug" === t.name));
        if (s > -1) {
            const [t] = o.splice(s, 1);
            o.push(t)
        }
        return o
    }
    function An(t, e) {
        for (const n of e)
            n && n.afterAllSetup && n.afterAllSetup(t)
    }
    function On(t, e, n) {
        if (n[e.name])
            a && m.log(`Integration skipped because it was already installed: ${e.name}`);
        else {
            if (n[e.name] = e,
            -1 === kn.indexOf(e.name) && "function" == typeof e.setupOnce && (e.setupOnce(),
            kn.push(e.name)),
            e.setup && "function" == typeof e.setup && e.setup(t),
            "function" == typeof e.preprocessEvent) {
                const n = e.preprocessEvent.bind(e);
                t.on("preprocessEvent", ( (e, r) => n(e, r, t)))
            }
            if ("function" == typeof e.processEvent) {
                const n = e.processEvent.bind(e)
                  , r = Object.assign(( (e, r) => n(e, r, t)), {
                    id: e.name
                });
                t.addEventProcessor(r)
            }
            a && m.log(`Integration installed: ${e.name}`)
        }
    }
    class Pn extends Error {
        constructor(t, e="warn") {
            super(t),
            this.message = t,
            this.name = new.target.prototype.constructor.name,
            Object.setPrototypeOf(this, new.target.prototype),
            this.logLevel = e
        }
    }
    const Cn = "Not capturing exception because it's already been captured.";
    class $n {
        constructor(t) {
            if (this._options = t,
            this._integrations = {},
            this._numProcessing = 0,
            this._outcomes = {},
            this._hooks = {},
            this._eventProcessors = [],
            t.dsn ? this._dsn = qe(t.dsn) : a && m.warn("No DSN provided, client will not send events."),
            this._dsn) {
                const o = (e = this._dsn,
                n = t.tunnel,
                r = t._metadata ? t._metadata.sdk : void 0,
                n || `${function(t) {
                    return `${function(t) {
                        const e = t.protocol ? `${t.protocol}:` : ""
                          , n = t.port ? `:${t.port}` : "";
                        return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`
                    }(t)}${t.projectId}/envelope/`
                }(e)}?${xn(e, r)}`);
                this._transport = t.transport({
                    tunnel: this._options.tunnel,
                    recordDroppedEvent: this.recordDroppedEvent.bind(this),
                    ...t.transportOptions,
                    url: o
                })
            }
            var e, n, r
        }
        captureException(t, e, n) {
            const r = gt();
            if (St(t))
                return a && m.log(Cn),
                r;
            const o = {
                event_id: r,
                ...e
            };
            return this._process(this.eventFromException(t, o).then((t => this._captureEvent(t, o, n)))),
            o.event_id
        }
        captureMessage(t, e, n, r) {
            const o = {
                event_id: gt(),
                ...n
            }
              , s = H(t) ? t : String(t)
              , i = B(t) ? this.eventFromMessage(s, e, o) : this.eventFromException(t, o);
            return this._process(i.then((t => this._captureEvent(t, o, r)))),
            o.event_id
        }
        captureEvent(t, e, n) {
            const r = gt();
            if (e && e.originalException && St(e.originalException))
                return a && m.log(Cn),
                r;
            const o = {
                event_id: r,
                ...e
            }
              , s = (t.sdkProcessingMetadata || {}).capturedSpanScope;
            return this._process(this._captureEvent(t, o, s || n)),
            o.event_id
        }
        captureSession(t) {
            "string" != typeof t.release ? a && m.warn("Discarded session because of missing or non-string release") : (this.sendSession(t),
            It(t, {
                init: !1
            }))
        }
        getDsn() {
            return this._dsn
        }
        getOptions() {
            return this._options
        }
        getSdkMetadata() {
            return this._options._metadata
        }
        getTransport() {
            return this._transport
        }
        flush(t) {
            const e = this._transport;
            return e ? (this.emit("flush"),
            this._isClientDoneProcessing(t).then((n => e.flush(t).then((t => n && t))))) : wt(!0)
        }
        close(t) {
            return this.flush(t).then((t => (this.getOptions().enabled = !1,
            this.emit("close"),
            t)))
        }
        getEventProcessors() {
            return this._eventProcessors
        }
        addEventProcessor(t) {
            this._eventProcessors.push(t)
        }
        init() {
            (this._isEnabled() || this._options.integrations.some(( ({name: t}) => t.startsWith("Spotlight")))) && this._setupIntegrations()
        }
        getIntegrationByName(t) {
            return this._integrations[t]
        }
        addIntegration(t) {
            const e = this._integrations[t.name];
            On(this, t, this._integrations),
            e || An(this, [t])
        }
        sendEvent(t, e={}) {
            this.emit("beforeSendEvent", t, e);
            let n = tn(t, this._dsn, this._options._metadata, this._options.tunnel);
            for (const t of e.attachments || [])
                n = ze(n, Je(t));
            const r = this.sendEnvelope(n);
            r && r.then((e => this.emit("afterSendEvent", t, e)), null)
        }
        sendSession(t) {
            const e = function(t, e, n, r) {
                const o = Ze(n);
                return Be({
                    sent_at: (new Date).toISOString(),
                    ...o && {
                        sdk: o
                    },
                    ...!!r && e && {
                        dsn: je(e)
                    }
                }, ["aggregates"in t ? [{
                    type: "sessions"
                }, t] : [{
                    type: "session"
                }, t.toJSON()]])
            }(t, this._dsn, this._options._metadata, this._options.tunnel);
            this.sendEnvelope(e)
        }
        recordDroppedEvent(t, e, n) {
            if (this._options.sendClientReports) {
                const r = "number" == typeof n ? n : 1
                  , o = `${t}:${e}`;
                a && m.log(`Recording outcome: "${o}"${r > 1 ? ` (${r} times)` : ""}`),
                this._outcomes[o] = (this._outcomes[o] || 0) + r
            }
        }
        on(t, e) {
            const n = this._hooks[t] = this._hooks[t] || [];
            return n.push(e),
            () => {
                const t = n.indexOf(e);
                t > -1 && n.splice(t, 1)
            }
        }
        emit(t, ...e) {
            const n = this._hooks[t];
            n && n.forEach((t => t(...e)))
        }
        sendEnvelope(t) {
            return this.emit("beforeEnvelope", t),
            this._isEnabled() && this._transport ? this._transport.send(t).then(null, (t => (a && m.error("Error while sending envelope:", t),
            t))) : (a && m.error("Transport disabled"),
            wt({}))
        }
        _setupIntegrations() {
            const {integrations: t} = this._options;
            this._integrations = function(t, e) {
                const n = {};
                return e.forEach((e => {
                    e && On(t, e, n)
                }
                )),
                n
            }(this, t),
            An(this, t)
        }
        _updateSessionFromEvent(t, e) {
            let n = !1
              , r = !1;
            const o = e.exception && e.exception.values;
            if (o) {
                r = !0;
                for (const t of o) {
                    const e = t.mechanism;
                    if (e && !1 === e.handled) {
                        n = !0;
                        break
                    }
                }
            }
            const s = "ok" === t.status;
            (s && 0 === t.errors || s && n) && (It(t, {
                ...n && {
                    status: "crashed"
                },
                errors: t.errors || Number(r || n)
            }),
            this.captureSession(t))
        }
        _isClientDoneProcessing(t) {
            return new xt((e => {
                let n = 0;
                const r = setInterval(( () => {
                    0 == this._numProcessing ? (clearInterval(r),
                    e(!0)) : (n += 1,
                    t && n >= t && (clearInterval(r),
                    e(!1)))
                }
                ), 1)
            }
            ))
        }
        _isEnabled() {
            return !1 !== this.getOptions().enabled && void 0 !== this._transport
        }
        _prepareEvent(t, e, n, r=Gt()) {
            const o = this.getOptions()
              , s = Object.keys(this._integrations);
            return !e.integrations && s.length > 0 && (e.integrations = s),
            this.emit("preprocessEvent", t, e),
            t.type || r.setLastEventId(t.event_id || e.event_id),
            vn(o, t, e, n, this, r).then((t => {
                if (null === t)
                    return t;
                const e = {
                    ...r.getPropagationContext(),
                    ...n ? n.getPropagationContext() : void 0
                };
                if (!(t.contexts && t.contexts.trace) && e) {
                    const {traceId: n, spanId: r, parentSpanId: o, dsc: s} = e;
                    t.contexts = {
                        trace: pt({
                            trace_id: n,
                            span_id: r,
                            parent_span_id: o
                        }),
                        ...t.contexts
                    };
                    const i = s || Re(n, this);
                    t.sdkProcessingMetadata = {
                        dynamicSamplingContext: i,
                        ...t.sdkProcessingMetadata
                    }
                }
                return t
            }
            ))
        }
        _captureEvent(t, e={}, n) {
            return this._processEvent(t, e, n).then((t => t.event_id), (t => {
                if (a) {
                    const e = t;
                    "log" === e.logLevel ? m.log(e.message) : m.warn(e)
                }
            }
            ))
        }
        _processEvent(t, e, n) {
            const r = this.getOptions()
              , {sampleRate: o} = r
              , s = Rn(t)
              , i = Dn(t)
              , a = t.type || "error"
              , c = `before send for type \`${a}\``
              , u = void 0 === o ? void 0 : Ne(o);
            if (i && "number" == typeof u && Math.random() > u)
                return this.recordDroppedEvent("sample_rate", "error", t),
                Tt(new Pn(`Discarding event because it's not included in the random sample (sampling rate = ${o})`,"log"));
            const d = "replay_event" === a ? "replay" : a
              , p = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
            return this._prepareEvent(t, e, n, p).then((n => {
                if (null === n)
                    throw this.recordDroppedEvent("event_processor", d, t),
                    new Pn("An event processor returned `null`, will not send event.","log");
                if (e.data && !0 === e.data.__sentry__)
                    return n;
                const o = function(t, e, n, r) {
                    const {beforeSend: o, beforeSendTransaction: s, beforeSendSpan: i} = e;
                    if (Dn(n) && o)
                        return o(n, r);
                    if (Rn(n)) {
                        if (n.spans && i) {
                            const e = [];
                            for (const r of n.spans) {
                                const n = i(r);
                                n ? e.push(n) : t.recordDroppedEvent("before_send", "span")
                            }
                            n.spans = e
                        }
                        if (s) {
                            if (n.spans) {
                                const t = n.spans.length;
                                n.sdkProcessingMetadata = {
                                    ...n.sdkProcessingMetadata,
                                    spanCountBeforeProcessing: t
                                }
                            }
                            return s(n, r)
                        }
                    }
                    return n
                }(this, r, n, e);
                return function(t, e) {
                    const n = `${e} must return \`null\` or a valid event.`;
                    if (W(t))
                        return t.then((t => {
                            if (!z(t) && null !== t)
                                throw new Pn(n);
                            return t
                        }
                        ), (t => {
                            throw new Pn(`${e} rejected with ${t}`)
                        }
                        ));
                    if (!z(t) && null !== t)
                        throw new Pn(n);
                    return t
                }(o, c)
            }
            )).then((r => {
                if (null === r) {
                    if (this.recordDroppedEvent("before_send", d, t),
                    s) {
                        const e = 1 + (t.spans || []).length;
                        this.recordDroppedEvent("before_send", "span", e)
                    }
                    throw new Pn(`${c} returned \`null\`, will not send event.`,"log")
                }
                const o = n && n.getSession();
                if (!s && o && this._updateSessionFromEvent(o, r),
                s) {
                    const t = (r.sdkProcessingMetadata && r.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (r.spans ? r.spans.length : 0);
                    t > 0 && this.recordDroppedEvent("before_send", "span", t)
                }
                const i = r.transaction_info;
                if (s && i && r.transaction !== t.transaction) {
                    const t = "custom";
                    r.transaction_info = {
                        ...i,
                        source: t
                    }
                }
                return this.sendEvent(r, e),
                r
            }
            )).then(null, (t => {
                if (t instanceof Pn)
                    throw t;
                throw this.captureException(t, {
                    data: {
                        __sentry__: !0
                    },
                    originalException: t
                }),
                new Pn(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${t}`)
            }
            ))
        }
        _process(t) {
            this._numProcessing++,
            t.then((t => (this._numProcessing--,
            t)), (t => (this._numProcessing--,
            t)))
        }
        _clearOutcomes() {
            const t = this._outcomes;
            return this._outcomes = {},
            Object.entries(t).map(( ([t,e]) => {
                const [n,r] = t.split(":");
                return {
                    reason: n,
                    category: r,
                    quantity: e
                }
            }
            ))
        }
        _flushOutcomes() {
            a && m.log("Flushing outcomes...");
            const t = this._clearOutcomes();
            if (0 === t.length)
                return void (a && m.log("No outcomes to send"));
            if (!this._dsn)
                return void (a && m.log("No dsn provided, will not send outcomes"));
            a && m.log("Sending outcomes:", t);
            const e = (n = t,
            Be((r = this._options.tunnel && je(this._dsn)) ? {
                dsn: r
            } : {}, [[{
                type: "client_report"
            }, {
                timestamp: ft(),
                discarded_events: n
            }]]));
            var n, r;
            this.sendEnvelope(e)
        }
    }
    function Dn(t) {
        return void 0 === t.type
    }
    function Rn(t) {
        return "transaction" === t.type
    }
    function Ln(t, e) {
        !0 === e.debug && (a ? m.enable() : h(( () => {
            console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
        }
        )));
        Ft().update(e.initialScope);
        const n = new t(e);
        return function(t) {
            Ft().setClient(t)
        }(n),
        n.init(),
        n
    }
    function Nn(t) {
        const e = [];
        function n(t) {
            return e.splice(e.indexOf(t), 1)[0] || Promise.resolve(void 0)
        }
        return {
            $: e,
            add: function(r) {
                if (!(void 0 === t || e.length < t))
                    return Tt(new Pn("Not adding Promise because buffer limit was reached."));
                const o = r();
                return -1 === e.indexOf(o) && e.push(o),
                o.then(( () => n(o))).then(null, ( () => n(o).then(null, ( () => {}
                )))),
                o
            },
            drain: function(t) {
                return new xt(( (n, r) => {
                    let o = e.length;
                    if (!o)
                        return n(!0);
                    const s = setTimeout(( () => {
                        t && t > 0 && n(!1)
                    }
                    ), t);
                    e.forEach((t => {
                        wt(t).then(( () => {
                            --o || (clearTimeout(s),
                            n(!0))
                        }
                        ), r)
                    }
                    ))
                }
                ))
            }
        }
    }
    function Mn(t, {statusCode: e, headers: n}, r=Date.now()) {
        const o = {
            ...t
        }
          , s = n && n["x-sentry-rate-limits"]
          , i = n && n["retry-after"];
        if (s)
            for (const t of s.trim().split(",")) {
                const [e,n,,,s] = t.split(":", 5)
                  , i = parseInt(e, 10)
                  , a = 1e3 * (isNaN(i) ? 60 : i);
                if (n)
                    for (const t of n.split(";"))
                        "metric_bucket" === t && s && !s.split(";").includes("custom") || (o[t] = r + a);
                else
                    o.all = r + a
            }
        else
            i ? o.all = r + function(t, e=Date.now()) {
                const n = parseInt(`${t}`, 10);
                if (!isNaN(n))
                    return 1e3 * n;
                const r = Date.parse(`${t}`);
                return isNaN(r) ? 6e4 : r - e
            }(i, r) : 429 === e && (o.all = r + 6e4);
        return o
    }
    function jn(t, e, n=Nn(t.bufferSize || 64)) {
        let r = {};
        return {
            send: function(o) {
                const s = [];
                if (Ve(o, ( (e, n) => {
                    const o = Qe(n);
                    if (function(t, e, n=Date.now()) {
                        return function(t, e) {
                            return t[e] || t.all || 0
                        }(t, e) > n
                    }(r, o)) {
                        const r = Un(e, n);
                        t.recordDroppedEvent("ratelimit_backoff", o, r)
                    } else
                        s.push(e)
                }
                )),
                0 === s.length)
                    return wt({});
                const i = Be(o[0], s)
                  , c = e => {
                    Ve(i, ( (n, r) => {
                        const o = Un(n, r);
                        t.recordDroppedEvent(e, Qe(r), o)
                    }
                    ))
                }
                ;
                return n.add(( () => e({
                    body: Ye(i)
                }).then((t => (void 0 !== t.statusCode && (t.statusCode < 200 || t.statusCode >= 300) && a && m.warn(`Sentry responded with status code ${t.statusCode} to sent event.`),
                r = Mn(r, t),
                t)), (t => {
                    throw c("network_error"),
                    t
                }
                )))).then((t => t), (t => {
                    if (t instanceof Pn)
                        return a && m.error("Skipped sending event because buffer is full."),
                        c("queue_overflow"),
                        wt({});
                    throw t
                }
                ))
            },
            flush: t => n.drain(t)
        }
    }
    function Un(t, e) {
        if ("event" === e || "transaction" === e)
            return Array.isArray(t) ? t[1] : void 0
    }
    const qn = 100;
    function Fn(t, e) {
        const n = Bt()
          , r = Gt();
        if (!n)
            return;
        const {beforeBreadcrumb: o=null, maxBreadcrumbs: s=qn} = n.getOptions();
        if (s <= 0)
            return;
        const i = {
            timestamp: ft(),
            ...t
        }
          , a = o ? h(( () => o(i, e))) : i;
        null !== a && (n.emit && n.emit("beforeAddBreadcrumb", a, e),
        r.addBreadcrumb(a, s))
    }
    let Gn;
    const Hn = new WeakMap
      , Bn = () => ({
        name: "FunctionToString",
        setupOnce() {
            Gn = Function.prototype.toString;
            try {
                Function.prototype.toString = function(...t) {
                    const e = at(this)
                      , n = Hn.has(Bt()) && void 0 !== e ? e : this;
                    return Gn.apply(n, t)
                }
            } catch (t) {}
        },
        setup(t) {
            Hn.set(t, !0)
        }
    })
      , zn = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", 'can\'t redefine non-configurable property "solana"', "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"]
      , Vn = (t={}) => ({
        name: "InboundFilters",
        processEvent(e, n, r) {
            const o = r.getOptions()
              , s = function(t={}, e={}) {
                return {
                    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
                    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
                    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : zn],
                    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
                    ignoreInternal: void 0 === t.ignoreInternal || t.ignoreInternal
                }
            }(t, o);
            return function(t, e) {
                if (e.ignoreInternal && function(t) {
                    try {
                        return "SentryError" === t.exception.values[0].type
                    } catch (t) {}
                    return !1
                }(t))
                    return a && m.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${vt(t)}`),
                    !0;
                if (function(t, e) {
                    if (t.type || !e || !e.length)
                        return !1;
                    return function(t) {
                        const e = [];
                        t.message && e.push(t.message);
                        let n;
                        try {
                            n = t.exception.values[t.exception.values.length - 1]
                        } catch (t) {}
                        n && n.value && (e.push(n.value),
                        n.type && e.push(`${n.type}: ${n.value}`));
                        return e
                    }(t).some((t => rt(t, e)))
                }(t, e.ignoreErrors))
                    return a && m.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${vt(t)}`),
                    !0;
                if (function(t) {
                    if (t.type)
                        return !1;
                    if (!t.exception || !t.exception.values || 0 === t.exception.values.length)
                        return !1;
                    return !t.message && !t.exception.values.some((t => t.stacktrace || t.type && "Error" !== t.type || t.value))
                }(t))
                    return a && m.warn(`Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${vt(t)}`),
                    !0;
                if (function(t, e) {
                    if ("transaction" !== t.type || !e || !e.length)
                        return !1;
                    const n = t.transaction;
                    return !!n && rt(n, e)
                }(t, e.ignoreTransactions))
                    return a && m.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${vt(t)}`),
                    !0;
                if (function(t, e) {
                    if (!e || !e.length)
                        return !1;
                    const n = Wn(t);
                    return !!n && rt(n, e)
                }(t, e.denyUrls))
                    return a && m.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${vt(t)}.\nUrl: ${Wn(t)}`),
                    !0;
                if (!function(t, e) {
                    if (!e || !e.length)
                        return !0;
                    const n = Wn(t);
                    return !n || rt(n, e)
                }(t, e.allowUrls))
                    return a && m.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${vt(t)}.\nUrl: ${Wn(t)}`),
                    !0;
                return !1
            }(e, s) ? null : e
        }
    });
    function Wn(t) {
        try {
            let e;
            try {
                e = t.exception.values[0].stacktrace.frames
            } catch (t) {}
            return e ? function(t=[]) {
                for (let e = t.length - 1; e >= 0; e--) {
                    const n = t[e];
                    if (n && "<anonymous>" !== n.filename && "[native code]" !== n.filename)
                        return n.filename || null
                }
                return null
            }(e) : null
        } catch (e) {
            return a && m.error(`Cannot extract url for event ${vt(t)}`),
            null
        }
    }
    function Yn(t, e, n=250, r, o, s, i) {
        if (!(s.exception && s.exception.values && i && Y(i.originalException, Error)))
            return;
        const a = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
        var c, u;
        a && (s.exception.values = (c = Xn(t, e, o, i.originalException, r, s.exception.values, a, 0),
        u = n,
        c.map((t => (t.value && (t.value = tt(t.value, u)),
        t)))))
    }
    function Xn(t, e, n, r, o, s, i, a) {
        if (s.length >= n + 1)
            return s;
        let c = [...s];
        if (Y(r[o], Error)) {
            Jn(i, a);
            const s = t(e, r[o])
              , u = c.length;
            Kn(s, o, u, a),
            c = Xn(t, e, n, r[o], o, [s, ...c], s, u)
        }
        return Array.isArray(r.errors) && r.errors.forEach(( (r, s) => {
            if (Y(r, Error)) {
                Jn(i, a);
                const u = t(e, r)
                  , d = c.length;
                Kn(u, `errors[${s}]`, d, a),
                c = Xn(t, e, n, r, o, [u, ...c], u, d)
            }
        }
        )),
        c
    }
    function Jn(t, e) {
        t.mechanism = t.mechanism || {
            type: "generic",
            handled: !0
        },
        t.mechanism = {
            ...t.mechanism,
            ..."AggregateError" === t.type && {
                is_exception_group: !0
            },
            exception_id: e
        }
    }
    function Kn(t, e, n, r) {
        t.mechanism = t.mechanism || {
            type: "generic",
            handled: !0
        },
        t.mechanism = {
            ...t.mechanism,
            type: "chained",
            source: e,
            exception_id: n,
            parent_id: r
        }
    }
    function Qn(t) {
        if (!t)
            return {};
        const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
        if (!e)
            return {};
        const n = e[6] || ""
          , r = e[8] || "";
        return {
            host: e[4],
            path: e[5],
            protocol: e[2],
            search: n,
            hash: r,
            relative: e[5] + n + r
        }
    }
    function Zn() {
        "console"in u && l.forEach((function(t) {
            t in u.console && ot(u.console, t, (function(e) {
                return f[t] = e,
                function(...e) {
                    A("console", {
                        args: e,
                        level: t
                    });
                    const n = f[t];
                    n && n.apply(u.console, e)
                }
            }
            ))
        }
        ))
    }
    const tr = ["fatal", "error", "warning", "log", "info", "debug"];
    function er(t) {
        return "warn" === t ? "warning" : tr.includes(t) ? t : "log"
    }
    const nr = () => {
        let t;
        return {
            name: "Dedupe",
            processEvent(e) {
                if (e.type)
                    return e;
                try {
                    if (function(t, e) {
                        if (!e)
                            return !1;
                        if (function(t, e) {
                            const n = t.message
                              , r = e.message;
                            if (!n && !r)
                                return !1;
                            if (n && !r || !n && r)
                                return !1;
                            if (n !== r)
                                return !1;
                            if (!or(t, e))
                                return !1;
                            if (!rr(t, e))
                                return !1;
                            return !0
                        }(t, e))
                            return !0;
                        if (function(t, e) {
                            const n = sr(e)
                              , r = sr(t);
                            if (!n || !r)
                                return !1;
                            if (n.type !== r.type || n.value !== r.value)
                                return !1;
                            if (!or(t, e))
                                return !1;
                            if (!rr(t, e))
                                return !1;
                            return !0
                        }(t, e))
                            return !0;
                        return !1
                    }(e, t))
                        return a && m.warn("Event dropped due to being a duplicate of previously captured event."),
                        null
                } catch (t) {}
                return t = e
            }
        }
    }
    ;
    function rr(t, e) {
        let n = w(t)
          , r = w(e);
        if (!n && !r)
            return !0;
        if (n && !r || !n && r)
            return !1;
        if (r.length !== n.length)
            return !1;
        for (let t = 0; t < r.length; t++) {
            const e = r[t]
              , o = n[t];
            if (e.filename !== o.filename || e.lineno !== o.lineno || e.colno !== o.colno || e.function !== o.function)
                return !1
        }
        return !0
    }
    function or(t, e) {
        let n = t.fingerprint
          , r = e.fingerprint;
        if (!n && !r)
            return !0;
        if (n && !r || !n && r)
            return !1;
        try {
            return !(n.join("") !== r.join(""))
        } catch (t) {
            return !1
        }
    }
    function sr(t) {
        return t.exception && t.exception.values && t.exception.values[0]
    }
    function ir(t, e, n, r, o="auto.http.browser") {
        if (!t.fetchData)
            return;
        const s = Oe() && e(t.fetchData.url);
        if (t.endTimestamp && s) {
            const e = t.fetchData.__span;
            if (!e)
                return;
            const n = r[e];
            return void (n && (!function(t, e) {
                if (e.response) {
                    te(t, e.response.status);
                    const n = e.response && e.response.headers && e.response.headers.get("content-length");
                    if (n) {
                        const e = parseInt(n);
                        e > 0 && t.setAttribute("http.response_content_length", e)
                    }
                } else
                    e.error && t.setStatus({
                        code: 2,
                        message: "internal_error"
                    });
                t.end()
            }(n, t),
            delete r[e]))
        }
        const i = Ft()
          , a = Bt()
          , {method: c, url: u} = t.fetchData
          , d = function(t) {
            try {
                return new URL(t).href
            } catch (t) {
                return
            }
        }(u)
          , p = d ? Qn(d).host : void 0
          , l = !!we()
          , f = s && l ? an({
            name: `${c} ${u}`,
            attributes: {
                url: u,
                type: "fetch",
                "http.method": c,
                "http.url": d,
                "server.address": p,
                [Xt]: o,
                [Yt]: "http.client"
            }
        }) : new Pe;
        if (t.fetchData.__span = f.spanContext().spanId,
        r[f.spanContext().spanId] = f,
        n(t.fetchData.url) && a) {
            const e = t.args[0];
            t.args[1] = t.args[1] || {};
            const n = t.args[1];
            n.headers = function(t, e, n, r, o) {
                const s = Gt()
                  , {traceId: i, spanId: a, sampled: c, dsc: u} = {
                    ...s.getPropagationContext(),
                    ...n.getPropagationContext()
                }
                  , d = o ? le(o) : ue(i, a, c)
                  , p = se(u || (o ? Le(o) : Re(i, e)))
                  , l = r.headers || ("undefined" != typeof Request && Y(t, Request) ? t.headers : void 0);
                if (l) {
                    if ("undefined" != typeof Headers && Y(l, Headers)) {
                        const t = new Headers(l);
                        if (t.set("sentry-trace", d),
                        p) {
                            const e = t.get(ee);
                            if (e) {
                                const n = ar(e);
                                t.set(ee, n ? `${n},${p}` : p)
                            } else
                                t.set(ee, p)
                        }
                        return t
                    }
                    if (Array.isArray(l)) {
                        const t = [...l.filter((t => !(Array.isArray(t) && "sentry-trace" === t[0]))).map((t => {
                            if (Array.isArray(t) && t[0] === ee && "string" == typeof t[1]) {
                                const [e,n,...r] = t;
                                return [e, ar(n), ...r]
                            }
                            return t
                        }
                        )), ["sentry-trace", d]];
                        return p && t.push([ee, p]),
                        t
                    }
                    {
                        const t = "baggage"in l ? l.baggage : void 0;
                        let e = [];
                        return Array.isArray(t) ? e = t.map((t => "string" == typeof t ? ar(t) : t)).filter((t => "" === t)) : t && e.push(ar(t)),
                        p && e.push(p),
                        {
                            ...l,
                            "sentry-trace": d,
                            baggage: e.length > 0 ? e.join(",") : void 0
                        }
                    }
                }
                return {
                    "sentry-trace": d,
                    baggage: p
                }
            }(e, a, i, n, Oe() && l ? f : void 0)
        }
        return f
    }
    function ar(t) {
        return t.split(",").filter((t => !t.split("=")[0].startsWith(ne))).join(",")
    }
    function cr(t) {
        return void 0 === t ? void 0 : t >= 400 && t < 500 ? "warning" : t >= 500 ? "error" : void 0
    }
    const ur = u;
    function dr() {
        if (!("fetch"in ur))
            return !1;
        try {
            return new Headers,
            new Request("http://www.example.com"),
            new Response,
            !0
        } catch (t) {
            return !1
        }
    }
    function pr(t) {
        return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
    }
    function lr(t, e) {
        const n = "fetch";
        k(n, t),
        I(n, ( () => fr(void 0, e)))
    }
    function fr(t, e=!1) {
        e && !function() {
            if ("string" == typeof EdgeRuntime)
                return !0;
            if (!dr())
                return !1;
            if (pr(ur.fetch))
                return !0;
            let t = !1;
            const e = ur.document;
            if (e && "function" == typeof e.createElement)
                try {
                    const n = e.createElement("iframe");
                    n.hidden = !0,
                    e.head.appendChild(n),
                    n.contentWindow && n.contentWindow.fetch && (t = pr(n.contentWindow.fetch)),
                    e.head.removeChild(n)
                } catch (t) {
                    p && m.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", t)
                }
            return t
        }() || ot(u, "fetch", (function(e) {
            return function(...n) {
                const {method: r, url: o} = function(t) {
                    if (0 === t.length)
                        return {
                            method: "GET",
                            url: ""
                        };
                    if (2 === t.length) {
                        const [e,n] = t;
                        return {
                            url: gr(e),
                            method: mr(n, "method") ? String(n.method).toUpperCase() : "GET"
                        }
                    }
                    const e = t[0];
                    return {
                        url: gr(e),
                        method: mr(e, "method") ? String(e.method).toUpperCase() : "GET"
                    }
                }(n)
                  , s = {
                    args: n,
                    fetchData: {
                        method: r,
                        url: o
                    },
                    startTimestamp: 1e3 * ht()
                };
                t || A("fetch", {
                    ...s
                });
                const i = (new Error).stack;
                return e.apply(u, n).then((async e => (t ? t(e) : A("fetch", {
                    ...s,
                    endTimestamp: 1e3 * ht(),
                    response: e
                }),
                e)), (t => {
                    throw A("fetch", {
                        ...s,
                        endTimestamp: 1e3 * ht(),
                        error: t
                    }),
                    j(t) && void 0 === t.stack && (t.stack = i,
                    st(t, "framesToPop", 1)),
                    t
                }
                ))
            }
        }
        ))
    }
    function hr(t) {
        let e;
        try {
            e = t.clone()
        } catch (t) {
            return
        }
        !async function(t, e) {
            if (t && t.body) {
                const n = t.body
                  , r = n.getReader()
                  , o = setTimeout(( () => {
                    n.cancel().then(null, ( () => {}
                    ))
                }
                ), 9e4);
                let s = !0;
                for (; s; ) {
                    let t;
                    try {
                        t = setTimeout(( () => {
                            n.cancel().then(null, ( () => {}
                            ))
                        }
                        ), 5e3);
                        const {done: o} = await r.read();
                        clearTimeout(t),
                        o && (e(),
                        s = !1)
                    } catch (t) {
                        s = !1
                    } finally {
                        clearTimeout(t)
                    }
                }
                clearTimeout(o),
                r.releaseLock(),
                n.cancel().then(null, ( () => {}
                ))
            }
        }(e, ( () => {
            A("fetch-body-resolved", {
                endTimestamp: 1e3 * ht(),
                response: t
            })
        }
        ))
    }
    function mr(t, e) {
        return !!t && "object" == typeof t && !!t[e]
    }
    function gr(t) {
        return "string" == typeof t ? t : t ? mr(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
    }
    const _r = u;
    function vr(t) {
        let e, n = t[0], r = 1;
        for (; r < t.length; ) {
            const o = t[r]
              , s = t[r + 1];
            if (r += 2,
            ("optionalAccess" === o || "optionalCall" === o) && null == n)
                return;
            "access" === o || "optionalAccess" === o ? (e = n,
            n = s(n)) : "call" !== o && "optionalCall" !== o || (n = s(( (...t) => n.call(e, ...t))),
            e = void 0)
        }
        return n
    }
    const yr = u;
    let br = 0;
    function Sr() {
        return br > 0
    }
    function Er(t, e={}, n) {
        if ("function" != typeof t)
            return t;
        try {
            const e = t.__sentry_wrapped__;
            if (e)
                return "function" == typeof e ? e : t;
            if (at(t))
                return t
        } catch (e) {
            return t
        }
        const r = function() {
            const n = Array.prototype.slice.call(arguments);
            try {
                const r = n.map((t => Er(t, e)));
                return t.apply(this, r)
            } catch (t) {
                throw br++,
                setTimeout(( () => {
                    br--
                }
                )),
                Ht((r => {
                    r.addEventProcessor((t => (e.mechanism && (yt(t, void 0),
                    bt(t, e.mechanism)),
                    t.extra = {
                        ...t.extra,
                        arguments: n
                    },
                    t))),
                    yn(t)
                }
                )),
                t
            }
        };
        try {
            for (const e in t)
                Object.prototype.hasOwnProperty.call(t, e) && (r[e] = t[e])
        } catch (t) {}
        it(r, t),
        st(t, "__sentry_wrapped__", r);
        try {
            Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
                get: () => t.name
            })
        } catch (t) {}
        return r
    }
    const wr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
    function Tr(t, e) {
        const n = Ir(t, e)
          , r = {
            type: Pr(e),
            value: Cr(e)
        };
        return n.length && (r.stacktrace = {
            frames: n
        }),
        void 0 === r.type && "" === r.value && (r.value = "Unrecoverable error caught"),
        r
    }
    function xr(t, e, n, r) {
        const o = Bt()
          , s = o && o.getOptions().normalizeDepth
          , i = function(t) {
            for (const e in t)
                if (Object.prototype.hasOwnProperty.call(t, e)) {
                    const n = t[e];
                    if (n instanceof Error)
                        return n
                }
            return
        }(e)
          , a = {
            __serialized__: Ge(e, s)
        };
        if (i)
            return {
                exception: {
                    values: [Tr(t, i)]
                },
                extra: a
            };
        const c = {
            exception: {
                values: [{
                    type: V(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                    value: Rr(e, {
                        isUnhandledRejection: r
                    })
                }]
            },
            extra: a
        };
        if (n) {
            const e = Ir(t, n);
            e.length && (c.exception.values[0].stacktrace = {
                frames: e
            })
        }
        return c
    }
    function kr(t, e) {
        return {
            exception: {
                values: [Tr(t, e)]
            }
        }
    }
    function Ir(t, e) {
        const n = e.stacktrace || e.stack || ""
          , r = function(t) {
            if (t && Ar.test(t.message))
                return 1;
            return 0
        }(e)
          , o = function(t) {
            if ("number" == typeof t.framesToPop)
                return t.framesToPop;
            return 0
        }(e);
        try {
            return t(n, r, o)
        } catch (t) {}
        return []
    }
    const Ar = /Minified React error #\d+;/i;
    function Or(t) {
        return "undefined" != typeof WebAssembly && void 0 !== WebAssembly.Exception && t instanceof WebAssembly.Exception
    }
    function Pr(t) {
        const e = t && t.name;
        if (!e && Or(t)) {
            return t.message && Array.isArray(t.message) && 2 == t.message.length ? t.message[0] : "WebAssembly.Exception"
        }
        return e
    }
    function Cr(t) {
        const e = t && t.message;
        return e ? e.error && "string" == typeof e.error.message ? e.error.message : Or(t) && Array.isArray(t.message) && 2 == t.message.length ? t.message[1] : e : "No error message"
    }
    function $r(t, e, n, r, o) {
        let s;
        if (q(e) && e.error) {
            return kr(t, e.error)
        }
        if (F(e) || U(e, "DOMException")) {
            const o = e;
            if ("stack"in e)
                s = kr(t, e);
            else {
                const e = o.name || (F(o) ? "DOMError" : "DOMException")
                  , i = o.message ? `${e}: ${o.message}` : e;
                s = Dr(t, i, n, r),
                yt(s, i)
            }
            return "code"in o && (s.tags = {
                ...s.tags,
                "DOMException.code": `${o.code}`
            }),
            s
        }
        if (j(e))
            return kr(t, e);
        if (z(e) || V(e)) {
            return s = xr(t, e, n, o),
            bt(s, {
                synthetic: !0
            }),
            s
        }
        return s = Dr(t, e, n, r),
        yt(s, `${e}`),
        bt(s, {
            synthetic: !0
        }),
        s
    }
    function Dr(t, e, n, r) {
        const o = {};
        if (r && n) {
            const r = Ir(t, n);
            r.length && (o.exception = {
                values: [{
                    value: e,
                    stacktrace: {
                        frames: r
                    }
                }]
            })
        }
        if (H(e)) {
            const {__sentry_template_string__: t, __sentry_template_values__: n} = e;
            return o.logentry = {
                message: t,
                params: n
            },
            o
        }
        return o.message = e,
        o
    }
    function Rr(t, {isUnhandledRejection: e}) {
        const n = function(t, e=40) {
            const n = Object.keys(ct(t));
            n.sort();
            const r = n[0];
            if (!r)
                return "[object has no keys]";
            if (r.length >= e)
                return tt(r, e);
            for (let t = n.length; t > 0; t--) {
                const r = n.slice(0, t).join(", ");
                if (!(r.length > e))
                    return t === n.length ? r : tt(r, e)
            }
            return ""
        }(t)
          , r = e ? "promise rejection" : "exception";
        if (q(t))
            return `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\``;
        if (V(t)) {
            return `Event \`${function(t) {
                try {
                    const e = Object.getPrototypeOf(t);
                    return e ? e.constructor.name : void 0
                } catch (t) {}
            }(t)}\` (type=${t.type}) captured as ${r}`
        }
        return `Object captured as ${r} with keys: ${n}`
    }
    class Lr extends $n {
        constructor(t) {
            const e = {
                parentSpanIsAlwaysRootSpan: !0,
                ...t
            };
            !function(t, e, n=[e], r="npm") {
                const o = t._metadata || {};
                o.sdk || (o.sdk = {
                    name: `sentry.javascript.${e}`,
                    packages: n.map((t => ({
                        name: `${r}:@sentry/${t}`,
                        version: c
                    }))),
                    version: c
                }),
                t._metadata = o
            }(e, "browser", ["browser"], yr.SENTRY_SDK_SOURCE || "npm"),
            super(e),
            e.sendClientReports && yr.document && yr.document.addEventListener("visibilitychange", ( () => {
                "hidden" === yr.document.visibilityState && this._flushOutcomes()
            }
            ))
        }
        eventFromException(t, e) {
            return function(t, e, n, r) {
                const o = $r(t, e, n && n.syntheticException || void 0, r);
                return bt(o),
                o.level = "error",
                n && n.event_id && (o.event_id = n.event_id),
                wt(o)
            }(this._options.stackParser, t, e, this._options.attachStacktrace)
        }
        eventFromMessage(t, e="info", n) {
            return function(t, e, n="info", r, o) {
                const s = Dr(t, e, r && r.syntheticException || void 0, o);
                return s.level = n,
                r && r.event_id && (s.event_id = r.event_id),
                wt(s)
            }(this._options.stackParser, t, e, n, this._options.attachStacktrace)
        }
        captureUserFeedback(t) {
            if (!this._isEnabled())
                return void (wr && m.warn("SDK not enabled, will not capture user feedback."));
            const e = function(t, {metadata: e, tunnel: n, dsn: r}) {
                const o = {
                    event_id: t.event_id,
                    sent_at: (new Date).toISOString(),
                    ...e && e.sdk && {
                        sdk: {
                            name: e.sdk.name,
                            version: e.sdk.version
                        }
                    },
                    ...!!n && !!r && {
                        dsn: je(r)
                    }
                }
                  , s = function(t) {
                    return [{
                        type: "user_report"
                    }, t]
                }(t);
                return Be(o, [s])
            }(t, {
                metadata: this.getSdkMetadata(),
                dsn: this.getDsn(),
                tunnel: this.getOptions().tunnel
            });
            this.sendEnvelope(e)
        }
        _prepareEvent(t, e, n) {
            return t.platform = t.platform || "javascript",
            super._prepareEvent(t, e, n)
        }
    }
    const Nr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
      , Mr = (t, e, n, r) => {
        let o, s;
        return i => {
            e.value >= 0 && (i || r) && (s = e.value - (o || 0),
            (s || void 0 === o) && (o = e.value,
            e.delta = s,
            e.rating = ( (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good")(e.value, n),
            t(e)))
        }
    }
      , jr = u
      , Ur = () => jr.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0]
      , qr = () => {
        const t = Ur();
        return t && t.activationStart || 0
    }
      , Fr = (t, e) => {
        const n = Ur();
        let r = "navigate";
        n && (jr.document && jr.document.prerendering || qr() > 0 ? r = "prerender" : jr.document && jr.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-")));
        return {
            name: t,
            value: void 0 === e ? -1 : e,
            rating: "good",
            delta: 0,
            entries: [],
            id: `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`,
            navigationType: r
        }
    }
      , Gr = (t, e, n) => {
        try {
            if (PerformanceObserver.supportedEntryTypes.includes(t)) {
                const r = new PerformanceObserver((t => {
                    Promise.resolve().then(( () => {
                        e(t.getEntries())
                    }
                    ))
                }
                ));
                return r.observe(Object.assign({
                    type: t,
                    buffered: !0
                }, n || {})),
                r
            }
        } catch (t) {}
    }
      , Hr = t => {
        const e = e => {
            ("pagehide" === e.type || jr.document && "hidden" === jr.document.visibilityState) && t(e)
        }
        ;
        jr.document && (addEventListener("visibilitychange", e, !0),
        addEventListener("pagehide", e, !0))
    }
      , Br = t => {
        let e = !1;
        return n => {
            e || (t(n),
            e = !0)
        }
    }
    ;
    let zr = -1;
    const Vr = t => {
        "hidden" === jr.document.visibilityState && zr > -1 && (zr = "visibilitychange" === t.type ? t.timeStamp : 0,
        removeEventListener("visibilitychange", Vr, !0),
        removeEventListener("prerenderingchange", Vr, !0))
    }
      , Wr = () => (jr.document && zr < 0 && (zr = "hidden" !== jr.document.visibilityState || jr.document.prerendering ? 1 / 0 : 0,
    addEventListener("visibilitychange", Vr, !0),
    addEventListener("prerenderingchange", Vr, !0)),
    {
        get firstHiddenTime() {
            return zr
        }
    })
      , Yr = t => {
        jr.document && jr.document.prerendering ? addEventListener("prerenderingchange", ( () => t()), !0) : t()
    }
      , Xr = [1800, 3e3]
      , Jr = [.1, .25]
      , Kr = (t, e={}) => {
        ( (t, e={}) => {
            Yr(( () => {
                const n = Wr()
                  , r = Fr("FCP");
                let o;
                const s = Gr("paint", (t => {
                    t.forEach((t => {
                        "first-contentful-paint" === t.name && (s.disconnect(),
                        t.startTime < n.firstHiddenTime && (r.value = Math.max(t.startTime - qr(), 0),
                        r.entries.push(t),
                        o(!0)))
                    }
                    ))
                }
                ));
                s && (o = Mr(t, r, Xr, e.reportAllChanges))
            }
            ))
        }
        )(Br(( () => {
            const n = Fr("CLS", 0);
            let r, o = 0, s = [];
            const i = t => {
                t.forEach((t => {
                    if (!t.hadRecentInput) {
                        const e = s[0]
                          , n = s[s.length - 1];
                        o && e && n && t.startTime - n.startTime < 1e3 && t.startTime - e.startTime < 5e3 ? (o += t.value,
                        s.push(t)) : (o = t.value,
                        s = [t])
                    }
                }
                )),
                o > n.value && (n.value = o,
                n.entries = s,
                r())
            }
              , a = Gr("layout-shift", i);
            a && (r = Mr(t, n, Jr, e.reportAllChanges),
            Hr(( () => {
                i(a.takeRecords()),
                r(!0)
            }
            )),
            setTimeout(r, 0))
        }
        )))
    }
      , Qr = [100, 300];
    let Zr = 0
      , to = 1 / 0
      , eo = 0;
    const no = t => {
        t.forEach((t => {
            t.interactionId && (to = Math.min(to, t.interactionId),
            eo = Math.max(eo, t.interactionId),
            Zr = eo ? (eo - to) / 7 + 1 : 0)
        }
        ))
    }
    ;
    let ro;
    const oo = () => {
        "interactionCount"in performance || ro || (ro = Gr("event", no, {
            type: "event",
            buffered: !0,
            durationThreshold: 0
        }))
    }
      , so = [200, 500]
      , io = () => (ro ? Zr : performance.interactionCount || 0) - 0
      , ao = []
      , co = {}
      , uo = t => {
        const e = ao[ao.length - 1]
          , n = co[t.interactionId];
        if (n || ao.length < 10 || e && t.duration > e.latency) {
            if (n)
                n.entries.push(t),
                n.latency = Math.max(n.latency, t.duration);
            else {
                const e = {
                    id: t.interactionId,
                    latency: t.duration,
                    entries: [t]
                };
                co[e.id] = e,
                ao.push(e)
            }
            ao.sort(( (t, e) => e.latency - t.latency)),
            ao.splice(10).forEach((t => {
                delete co[t.id]
            }
            ))
        }
    }
      , po = (t, e={}) => {
        Yr(( () => {
            oo();
            const n = Fr("INP");
            let r;
            const o = t => {
                t.forEach((t => {
                    if (t.interactionId && uo(t),
                    "first-input" === t.entryType) {
                        !ao.some((e => e.entries.some((e => t.duration === e.duration && t.startTime === e.startTime)))) && uo(t)
                    }
                }
                ));
                const e = ( () => {
                    const t = Math.min(ao.length - 1, Math.floor(io() / 50));
                    return ao[t]
                }
                )();
                e && e.latency !== n.value && (n.value = e.latency,
                n.entries = e.entries,
                r())
            }
              , s = Gr("event", o, {
                durationThreshold: null != e.durationThreshold ? e.durationThreshold : 40
            });
            r = Mr(t, n, so, e.reportAllChanges),
            s && ("PerformanceEventTiming"in jr && "interactionId"in PerformanceEventTiming.prototype && s.observe({
                type: "first-input",
                buffered: !0
            }),
            Hr(( () => {
                o(s.takeRecords()),
                n.value < 0 && io() > 0 && (n.value = 0,
                n.entries = []),
                r(!0)
            }
            )))
        }
        ))
    }
      , lo = [2500, 4e3]
      , fo = {}
      , ho = [800, 1800]
      , mo = t => {
        jr.document && jr.document.prerendering ? Yr(( () => mo(t))) : jr.document && "complete" !== jr.document.readyState ? addEventListener("load", ( () => mo(t)), !0) : setTimeout(t, 0)
    }
      , go = {}
      , _o = {};
    let vo, yo, bo, So, Eo;
    function wo(t, e=!1) {
        return Co("cls", t, ko, vo, e)
    }
    function To(t, e) {
        return $o(t, e),
        _o[t] || (!function(t) {
            const e = {};
            "event" === t && (e.durationThreshold = 0);
            Gr(t, (e => {
                xo(t, {
                    entries: e
                })
            }
            ), e)
        }(t),
        _o[t] = !0),
        Do(t, e)
    }
    function xo(t, e) {
        const n = go[t];
        if (n && n.length)
            for (const r of n)
                try {
                    r(e)
                } catch (e) {
                    Nr && m.error(`Error while triggering instrumentation handler.\nType: ${t}\nName: ${E(r)}\nError:`, e)
                }
    }
    function ko() {
        return Kr((t => {
            xo("cls", {
                metric: t
            }),
            vo = t
        }
        ), {
            reportAllChanges: !0
        })
    }
    function Io() {
        return ( (t, e={}) => {
            Yr(( () => {
                const n = Wr()
                  , r = Fr("FID");
                let o;
                const s = t => {
                    t.startTime < n.firstHiddenTime && (r.value = t.processingStart - t.startTime,
                    r.entries.push(t),
                    o(!0))
                }
                  , i = t => {
                    t.forEach(s)
                }
                  , a = Gr("first-input", i);
                o = Mr(t, r, Qr, e.reportAllChanges),
                a && Hr(Br(( () => {
                    i(a.takeRecords()),
                    a.disconnect()
                }
                )))
            }
            ))
        }
        )((t => {
            xo("fid", {
                metric: t
            }),
            yo = t
        }
        ))
    }
    function Ao() {
        return ( (t, e={}) => {
            Yr(( () => {
                const n = Wr()
                  , r = Fr("LCP");
                let o;
                const s = t => {
                    const e = t[t.length - 1];
                    e && e.startTime < n.firstHiddenTime && (r.value = Math.max(e.startTime - qr(), 0),
                    r.entries = [e],
                    o())
                }
                  , i = Gr("largest-contentful-paint", s);
                if (i) {
                    o = Mr(t, r, lo, e.reportAllChanges);
                    const n = Br(( () => {
                        fo[r.id] || (s(i.takeRecords()),
                        i.disconnect(),
                        fo[r.id] = !0,
                        o(!0))
                    }
                    ));
                    ["keydown", "click"].forEach((t => {
                        jr.document && addEventListener(t, ( () => setTimeout(n, 0)), !0)
                    }
                    )),
                    Hr(n)
                }
            }
            ))
        }
        )((t => {
            xo("lcp", {
                metric: t
            }),
            bo = t
        }
        ), {
            reportAllChanges: !0
        })
    }
    function Oo() {
        return ( (t, e={}) => {
            const n = Fr("TTFB")
              , r = Mr(t, n, ho, e.reportAllChanges);
            mo(( () => {
                const t = Ur();
                if (t) {
                    const e = t.responseStart;
                    if (e <= 0 || e > performance.now())
                        return;
                    n.value = Math.max(e - qr(), 0),
                    n.entries = [t],
                    r(!0)
                }
            }
            ))
        }
        )((t => {
            xo("ttfb", {
                metric: t
            }),
            So = t
        }
        ))
    }
    function Po() {
        return po((t => {
            xo("inp", {
                metric: t
            }),
            Eo = t
        }
        ))
    }
    function Co(t, e, n, r, o=!1) {
        let s;
        return $o(t, e),
        _o[t] || (s = n(),
        _o[t] = !0),
        r && e({
            metric: r
        }),
        Do(t, e, o ? s : void 0)
    }
    function $o(t, e) {
        go[t] = go[t] || [],
        go[t].push(e)
    }
    function Do(t, e, n) {
        return () => {
            n && n();
            const r = go[t];
            if (!r)
                return;
            const o = r.indexOf(e);
            -1 !== o && r.splice(o, 1)
        }
    }
    function Ro(t) {
        return "number" == typeof t && isFinite(t)
    }
    function Lo(t, e, n, {...r}) {
        const o = me(t).start_timestamp;
        return o && o > e && "function" == typeof t.updateStartTime && t.updateStartTime(e),
        cn(t, ( () => {
            const t = an({
                startTime: e,
                ...r
            });
            return t && t.end(n),
            t
        }
        ))
    }
    function No(t) {
        const e = Bt();
        if (!e)
            return;
        const {name: n, transaction: r, attributes: o, startTime: s} = t
          , {release: i, environment: a} = e.getOptions()
          , c = e.getIntegrationByName("Replay")
          , u = c && c.getReplayId()
          , d = Ft()
          , p = d.getUser()
          , l = void 0 !== p ? p.email || p.id || p.ip_address : void 0;
        let f;
        try {
            f = d.getScopeData().contexts.profile.profile_id
        } catch (t) {}
        return an({
            name: n,
            attributes: {
                release: i,
                environment: a,
                user: l || void 0,
                profile_id: f || void 0,
                replay_id: u || void 0,
                transaction: r,
                "user_agent.original": jr.navigator && jr.navigator.userAgent,
                ...o
            },
            startTime: s,
            experimental: {
                standalone: !0
            }
        })
    }
    function Mo() {
        return jr && jr.addEventListener && jr.performance
    }
    function jo(t) {
        return t / 1e3
    }
    function Uo() {
        let t, e, n = 0;
        if (!function() {
            try {
                return vr([PerformanceObserver, "access", t => t.supportedEntryTypes, "optionalAccess", t => t.includes, "call", t => t("layout-shift")])
            } catch (t) {
                return !1
            }
        }())
            return;
        let r = !1;
        function o() {
            r || (r = !0,
            e && function(t, e, n) {
                Nr && m.log(`Sending CLS span (${t})`);
                const r = jo((mt || 0) + (vr([e, "optionalAccess", t => t.startTime]) || 0))
                  , o = Ft().getScopeData().transactionName
                  , s = e ? K(vr([e, "access", t => t.sources, "access", t => t[0], "optionalAccess", t => t.node])) : "Layout shift"
                  , i = pt({
                    [Xt]: "auto.http.browser.cls",
                    [Yt]: "ui.webvital.cls",
                    [Zt]: vr([e, "optionalAccess", t => t.duration]) || 0,
                    "sentry.pageload.span_id": n
                })
                  , a = No({
                    name: s,
                    transaction: o,
                    attributes: i,
                    startTime: r
                });
                vr([a, "optionalAccess", t => t.addEvent, "call", e => e("cls", {
                    [Kt]: "",
                    [Qt]: t
                })]),
                vr([a, "optionalAccess", t => t.end, "call", t => t(r)])
            }(n, t, e),
            s())
        }
        const s = wo(( ({metric: e}) => {
            const r = e.entries[e.entries.length - 1];
            r && (n = e.value,
            t = r)
        }
        ), !0);
        Hr(( () => {
            o()
        }
        )),
        setTimeout(( () => {
            const t = vr([Bt(), "optionalAccess", t => t.on, "call", e => e("startNavigationSpan", ( () => {
                o(),
                t && t()
            }
            ))])
              , n = we()
              , r = n && Ee(n)
              , s = r && me(r);
            s && "pageload" === s.op && (e = r.spanContext().spanId)
        }
        ), 0)
    }
    let qo, Fo, Go = 0, Ho = {};
    function Bo({recordClsStandaloneSpans: t}) {
        const e = Mo();
        if (e && mt) {
            e.mark && jr.performance.mark("sentry-tracing-init");
            const n = Co("fid", ( ({metric: t}) => {
                const e = t.entries[t.entries.length - 1];
                if (!e)
                    return;
                const n = jo(mt)
                  , r = jo(e.startTime);
                Nr && m.log("[Measurements] Adding FID"),
                Ho.fid = {
                    value: t.value,
                    unit: "millisecond"
                },
                Ho["mark.fid"] = {
                    value: n + r,
                    unit: "second"
                }
            }
            ), Io, yo)
              , r = function(t, e=!1) {
                return Co("lcp", t, Ao, bo, e)
            }(( ({metric: t}) => {
                const e = t.entries[t.entries.length - 1];
                e && (Nr && m.log("[Measurements] Adding LCP"),
                Ho.lcp = {
                    value: t.value,
                    unit: "millisecond"
                },
                qo = e)
            }
            ), !0)
              , o = function(t) {
                return Co("ttfb", t, Oo, So)
            }(( ({metric: t}) => {
                t.entries[t.entries.length - 1] && (Nr && m.log("[Measurements] Adding TTFB"),
                Ho.ttfb = {
                    value: t.value,
                    unit: "millisecond"
                })
            }
            ))
              , s = t ? Uo() : wo(( ({metric: t}) => {
                const e = t.entries[t.entries.length - 1];
                e && (Nr && m.log(`[Measurements] Adding CLS ${t.value}`),
                Ho.cls = {
                    value: t.value,
                    unit: ""
                },
                Fo = e)
            }
            ), !0);
            return () => {
                n(),
                r(),
                o(),
                s && s()
            }
        }
        return () => {}
    }
    function zo(t, e) {
        const n = Mo();
        if (!n || !jr.performance.getEntries || !mt)
            return;
        Nr && m.log("[Tracing] Adding & adjusting spans using Performance API");
        const r = jo(mt)
          , o = n.getEntries()
          , {op: s, start_timestamp: i} = me(t);
        if (o.slice(Go).forEach((e => {
            const n = jo(e.startTime)
              , o = jo(Math.max(0, e.duration));
            if (!("navigation" === s && i && r + n < i))
                switch (e.entryType) {
                case "navigation":
                    !function(t, e, n) {
                        ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r => {
                            Vo(t, e, r, n)
                        }
                        )),
                        Vo(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"),
                        Vo(t, e, "fetch", n, "cache", "domainLookupStart"),
                        Vo(t, e, "domainLookup", n, "DNS"),
                        function(t, e, n) {
                            const r = n + jo(e.requestStart)
                              , o = n + jo(e.responseEnd)
                              , s = n + jo(e.responseStart);
                            e.responseEnd && (Lo(t, r, o, {
                                op: "browser.request",
                                name: e.name,
                                attributes: {
                                    [Xt]: "auto.ui.browser.metrics"
                                }
                            }),
                            Lo(t, s, o, {
                                op: "browser.response",
                                name: e.name,
                                attributes: {
                                    [Xt]: "auto.ui.browser.metrics"
                                }
                            }))
                        }(t, e, n)
                    }(t, e, r);
                    break;
                case "mark":
                case "paint":
                case "measure":
                    {
                        !function(t, e, n, r, o) {
                            const s = Ur()
                              , i = jo(s ? s.requestStart : 0)
                              , a = o + Math.max(n, i)
                              , c = o + n
                              , u = c + r
                              , d = {
                                [Xt]: "auto.resource.browser.metrics"
                            };
                            a !== c && (d["sentry.browser.measure_happened_before_request"] = !0,
                            d["sentry.browser.measure_start_time"] = a);
                            Lo(t, a, u, {
                                name: e.name,
                                op: e.entryType,
                                attributes: d
                            })
                        }(t, e, n, o, r);
                        const s = Wr()
                          , i = e.startTime < s.firstHiddenTime;
                        "first-paint" === e.name && i && (Nr && m.log("[Measurements] Adding FP"),
                        Ho.fp = {
                            value: e.startTime,
                            unit: "millisecond"
                        }),
                        "first-contentful-paint" === e.name && i && (Nr && m.log("[Measurements] Adding FCP"),
                        Ho.fcp = {
                            value: e.startTime,
                            unit: "millisecond"
                        });
                        break
                    }
                case "resource":
                    !function(t, e, n, r, o, s) {
                        if ("xmlhttprequest" === e.initiatorType || "fetch" === e.initiatorType)
                            return;
                        const i = Qn(n)
                          , a = {
                            [Xt]: "auto.resource.browser.metrics"
                        };
                        Wo(a, e, "transferSize", "http.response_transfer_size"),
                        Wo(a, e, "encodedBodySize", "http.response_content_length"),
                        Wo(a, e, "decodedBodySize", "http.decoded_response_content_length"),
                        null != e.deliveryType && (a["http.response_delivery_type"] = e.deliveryType);
                        "renderBlockingStatus"in e && (a["resource.render_blocking_status"] = e.renderBlockingStatus);
                        i.protocol && (a["url.scheme"] = i.protocol.split(":").pop());
                        i.host && (a["server.address"] = i.host);
                        a["url.same_origin"] = n.includes(jr.location.origin);
                        const c = s + r
                          , u = c + o;
                        Lo(t, c, u, {
                            name: n.replace(jr.location.origin, ""),
                            op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
                            attributes: a
                        })
                    }(t, e, e.name, n, o, r)
                }
        }
        )),
        Go = Math.max(o.length - 1, 0),
        function(t) {
            const e = jr.navigator;
            if (!e)
                return;
            const n = e.connection;
            n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType),
            n.type && t.setAttribute("connectionType", n.type),
            Ro(n.rtt) && (Ho["connection.rtt"] = {
                value: n.rtt,
                unit: "millisecond"
            }));
            Ro(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`);
            Ro(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency))
        }(t),
        "pageload" === s) {
            !function(t) {
                const e = Ur();
                if (!e)
                    return;
                const {responseStart: n, requestStart: r} = e;
                r <= n && (Nr && m.log("[Measurements] Adding TTFB Request Time"),
                t["ttfb.requestTime"] = {
                    value: n - r,
                    unit: "millisecond"
                })
            }(Ho);
            const n = Ho["mark.fid"];
            n && Ho.fid && (Lo(t, n.value, n.value + jo(Ho.fid.value), {
                name: "first input delay",
                op: "ui.action",
                attributes: {
                    [Xt]: "auto.ui.browser.metrics"
                }
            }),
            delete Ho["mark.fid"]),
            "fcp"in Ho && e.recordClsOnPageloadSpan || delete Ho.cls,
            Object.entries(Ho).forEach(( ([t,e]) => {
                !function(t, e, n, r=we()) {
                    const o = r && Ee(r);
                    o && o.addEvent(t, {
                        [Qt]: e,
                        [Kt]: n
                    })
                }(t, e.value, e.unit)
            }
            )),
            t.setAttribute("performance.timeOrigin", r),
            t.setAttribute("performance.activationStart", qr()),
            function(t) {
                qo && (Nr && m.log("[Measurements] Adding LCP Data"),
                qo.element && t.setAttribute("lcp.element", K(qo.element)),
                qo.id && t.setAttribute("lcp.id", qo.id),
                qo.url && t.setAttribute("lcp.url", qo.url.trim().slice(0, 200)),
                null != qo.loadTime && t.setAttribute("lcp.loadTime", qo.loadTime),
                null != qo.renderTime && t.setAttribute("lcp.renderTime", qo.renderTime),
                t.setAttribute("lcp.size", qo.size));
                Fo && Fo.sources && (Nr && m.log("[Measurements] Adding CLS Data"),
                Fo.sources.forEach(( (e, n) => t.setAttribute(`cls.source.${n + 1}`, K(e.node)))))
            }(t)
        }
        qo = void 0,
        Fo = void 0,
        Ho = {}
    }
    function Vo(t, e, n, r, o, s) {
        const i = s ? e[s] : e[`${n}End`]
          , a = e[`${n}Start`];
        a && i && Lo(t, r + jo(a), r + jo(i), {
            op: `browser.${o || n}`,
            name: e.name,
            attributes: {
                [Xt]: "auto.ui.browser.metrics"
            }
        })
    }
    function Wo(t, e, n, r) {
        const o = e[n];
        null != o && o < 2147483647 && (t[r] = o)
    }
    let Yo, Xo, Jo, Ko;
    function Qo() {
        if (!jr.document)
            return;
        const t = A.bind(null, "dom")
          , e = Zo(t, !0);
        jr.document.addEventListener("click", e, !1),
        jr.document.addEventListener("keypress", e, !1),
        ["EventTarget", "Node"].forEach((e => {
            const n = jr[e] && jr[e].prototype;
            n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (ot(n, "addEventListener", (function(e) {
                return function(n, r, o) {
                    if ("click" === n || "keypress" == n)
                        try {
                            const r = this
                              , s = r.__sentry_instrumentation_handlers__ = r.__sentry_instrumentation_handlers__ || {}
                              , i = s[n] = s[n] || {
                                refCount: 0
                            };
                            if (!i.handler) {
                                const r = Zo(t);
                                i.handler = r,
                                e.call(this, n, r, o)
                            }
                            i.refCount++
                        } catch (t) {}
                    return e.call(this, n, r, o)
                }
            }
            )),
            ot(n, "removeEventListener", (function(t) {
                return function(e, n, r) {
                    if ("click" === e || "keypress" == e)
                        try {
                            const n = this
                              , o = n.__sentry_instrumentation_handlers__ || {}
                              , s = o[e];
                            s && (s.refCount--,
                            s.refCount <= 0 && (t.call(this, e, s.handler, r),
                            s.handler = void 0,
                            delete o[e]),
                            0 === Object.keys(o).length && delete n.__sentry_instrumentation_handlers__)
                        } catch (t) {}
                    return t.call(this, e, n, r)
                }
            }
            )))
        }
        ))
    }
    function Zo(t, e=!1) {
        return n => {
            if (!n || n._sentryCaptured)
                return;
            const r = function(t) {
                try {
                    return t.target
                } catch (t) {
                    return null
                }
            }(n);
            if (function(t, e) {
                return "keypress" === t && (!e || !e.tagName || "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName && !e.isContentEditable)
            }(n.type, r))
                return;
            st(n, "_sentryCaptured", !0),
            r && !r._sentryId && st(r, "_sentryId", gt());
            const o = "keypress" === n.type ? "input" : n.type;
            if (!function(t) {
                if (t.type !== Xo)
                    return !1;
                try {
                    if (!t.target || t.target._sentryId !== Jo)
                        return !1
                } catch (t) {}
                return !0
            }(n)) {
                t({
                    event: n,
                    name: o,
                    global: e
                }),
                Xo = n.type,
                Jo = r ? r._sentryId : void 0
            }
            clearTimeout(Yo),
            Yo = jr.setTimeout(( () => {
                Jo = void 0,
                Xo = void 0
            }
            ), 1e3)
        }
    }
    function ts(t) {
        const e = "history";
        k(e, t),
        I(e, es)
    }
    function es() {
        if (!function() {
            const t = _r.chrome
              , e = t && t.app && t.app.runtime
              , n = "history"in _r && !!_r.history.pushState && !!_r.history.replaceState;
            return !e && n
        }())
            return;
        const t = jr.onpopstate;
        function e(t) {
            return function(...e) {
                const n = e.length > 2 ? e[2] : void 0;
                if (n) {
                    const t = Ko
                      , e = String(n);
                    Ko = e;
                    A("history", {
                        from: t,
                        to: e
                    })
                }
                return t.apply(this, e)
            }
        }
        jr.onpopstate = function(...e) {
            const n = jr.location.href
              , r = Ko;
            Ko = n;
            if (A("history", {
                from: r,
                to: n
            }),
            t)
                try {
                    return t.apply(this, e)
                } catch (t) {}
        }
        ,
        ot(jr.history, "pushState", e),
        ot(jr.history, "replaceState", e)
    }
    const ns = {};
    function rs(t) {
        ns[t] = void 0
    }
    const os = "__sentry_xhr_v3__";
    function ss(t) {
        k("xhr", t),
        I("xhr", is)
    }
    function is() {
        if (!jr.XMLHttpRequest)
            return;
        const t = XMLHttpRequest.prototype;
        t.open = new Proxy(t.open,{
            apply(t, e, n) {
                const r = 1e3 * ht()
                  , o = G(n[0]) ? n[0].toUpperCase() : void 0
                  , s = function(t) {
                    if (G(t))
                        return t;
                    try {
                        return t.toString()
                    } catch (t) {}
                    return
                }(n[1]);
                if (!o || !s)
                    return t.apply(e, n);
                e[os] = {
                    method: o,
                    url: s,
                    request_headers: {}
                },
                "POST" === o && s.match(/sentry_key/) && (e.__sentry_own_request__ = !0);
                const i = () => {
                    const t = e[os];
                    if (t && 4 === e.readyState) {
                        try {
                            t.status_code = e.status
                        } catch (t) {}
                        A("xhr", {
                            endTimestamp: 1e3 * ht(),
                            startTimestamp: r,
                            xhr: e
                        })
                    }
                }
                ;
                return "onreadystatechange"in e && "function" == typeof e.onreadystatechange ? e.onreadystatechange = new Proxy(e.onreadystatechange,{
                    apply: (t, e, n) => (i(),
                    t.apply(e, n))
                }) : e.addEventListener("readystatechange", i),
                e.setRequestHeader = new Proxy(e.setRequestHeader,{
                    apply(t, e, n) {
                        const [r,o] = n
                          , s = e[os];
                        return s && G(r) && G(o) && (s.request_headers[r.toLowerCase()] = o),
                        t.apply(e, n)
                    }
                }),
                t.apply(e, n)
            }
        }),
        t.send = new Proxy(t.send,{
            apply(t, e, n) {
                const r = e[os];
                if (!r)
                    return t.apply(e, n);
                void 0 !== n[0] && (r.body = n[0]);
                return A("xhr", {
                    startTimestamp: 1e3 * ht(),
                    xhr: e
                }),
                t.apply(e, n)
            }
        })
    }
    const as = []
      , cs = new Map;
    function us() {
        if (Mo() && mt) {
            const t = Co("inp", ( ({metric: t}) => {
                if (null == t.value)
                    return;
                const e = t.entries.find((e => e.duration === t.value && ds[e.name]));
                if (!e)
                    return;
                const {interactionId: n} = e
                  , r = ds[e.name]
                  , o = jo(mt + e.startTime)
                  , s = jo(t.value)
                  , i = we()
                  , a = i ? Ee(i) : void 0
                  , c = (null != n ? cs.get(n) : void 0) || a
                  , u = c ? me(c).description : Ft().getScopeData().transactionName
                  , d = No({
                    name: K(e.target),
                    transaction: u,
                    attributes: pt({
                        [Xt]: "auto.http.browser.inp",
                        [Yt]: `ui.interaction.${r}`,
                        [Zt]: e.duration
                    }),
                    startTime: o
                });
                vr([d, "optionalAccess", t => t.addEvent, "call", e => e("inp", {
                    [Kt]: "millisecond",
                    [Qt]: t.value
                })]),
                vr([d, "optionalAccess", t => t.end, "call", t => t(o + s)])
            }
            ), Po, Eo);
            return () => {
                t()
            }
        }
        return () => {}
    }
    const ds = {
        click: "click",
        pointerdown: "click",
        pointerup: "click",
        mousedown: "click",
        mouseup: "click",
        touchstart: "click",
        touchend: "click",
        mouseover: "hover",
        mouseout: "hover",
        mouseenter: "hover",
        mouseleave: "hover",
        pointerover: "hover",
        pointerout: "hover",
        pointerenter: "hover",
        pointerleave: "hover",
        dragstart: "drag",
        dragend: "drag",
        drag: "drag",
        dragenter: "drag",
        dragleave: "drag",
        dragover: "drag",
        drop: "drag",
        keydown: "press",
        keyup: "press",
        keypress: "press",
        input: "press"
    };
    function ps(t, e=function(t) {
        const e = ns[t];
        if (e)
            return e;
        let n = jr[t];
        if (pr(n))
            return ns[t] = n.bind(jr);
        const r = jr.document;
        if (r && "function" == typeof r.createElement)
            try {
                const e = r.createElement("iframe");
                e.hidden = !0,
                r.head.appendChild(e);
                const o = e.contentWindow;
                o && o[t] && (n = o[t]),
                r.head.removeChild(e)
            } catch (e) {
                Nr && m.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, e)
            }
        return n ? ns[t] = n.bind(jr) : n
    }("fetch")) {
        let n = 0
          , r = 0;
        return jn(t, (function(o) {
            const s = o.body.length;
            n += s,
            r++;
            const i = {
                body: o.body,
                method: "POST",
                referrerPolicy: "origin",
                headers: t.headers,
                keepalive: n <= 6e4 && r < 15,
                ...t.fetchOptions
            };
            if (!e)
                return rs("fetch"),
                Tt("No fetch implementation available");
            try {
                return e(t.url, i).then((t => (n -= s,
                r--,
                {
                    statusCode: t.status,
                    headers: {
                        "x-sentry-rate-limits": t.headers.get("X-Sentry-Rate-Limits"),
                        "retry-after": t.headers.get("Retry-After")
                    }
                })))
            } catch (t) {
                return rs("fetch"),
                n -= s,
                r--,
                Tt(t)
            }
        }
        ))
    }
    function ls(t, e, n, r) {
        const o = {
            filename: t,
            function: "<anonymous>" === e ? g : e,
            in_app: !0
        };
        return void 0 !== n && (o.lineno = n),
        void 0 !== r && (o.colno = r),
        o
    }
    const fs = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i
      , hs = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
      , ms = /\((\S*)(?::(\d+))(?::(\d+))\)/
      , gs = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
      , _s = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
      , vs = y(...[[30, t => {
        const e = fs.exec(t);
        if (e) {
            const [,t,n,r] = e;
            return ls(t, g, +n, +r)
        }
        const n = hs.exec(t);
        if (n) {
            if (n[2] && 0 === n[2].indexOf("eval")) {
                const t = ms.exec(n[2]);
                t && (n[2] = t[1],
                n[3] = t[2],
                n[4] = t[3])
            }
            const [t,e] = ys(n[1] || g, n[2]);
            return ls(e, t, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0)
        }
    }
    ], [50, t => {
        const e = gs.exec(t);
        if (e) {
            if (e[3] && e[3].indexOf(" > eval") > -1) {
                const t = _s.exec(e[3]);
                t && (e[1] = e[1] || "eval",
                e[3] = t[1],
                e[4] = t[2],
                e[5] = "")
            }
            let t = e[3]
              , n = e[1] || g;
            return [n,t] = ys(n, t),
            ls(t, n, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
        }
    }
    ]])
      , ys = (t, e) => {
        const n = -1 !== t.indexOf("safari-extension")
          , r = -1 !== t.indexOf("safari-web-extension");
        return n || r ? [-1 !== t.indexOf("@") ? t.split("@")[0] : g, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
    }
      , bs = 1024
      , Ss = (t={}) => {
        const e = {
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0,
            ...t
        };
        return {
            name: "Breadcrumbs",
            setup(t) {
                var n;
                e.console && function(t) {
                    const e = "console";
                    k(e, t),
                    I(e, Zn)
                }(function(t) {
                    return function(e) {
                        if (Bt() !== t)
                            return;
                        const n = {
                            category: "console",
                            data: {
                                arguments: e.args,
                                logger: "console"
                            },
                            level: er(e.level),
                            message: et(e.args, " ")
                        };
                        if ("assert" === e.level) {
                            if (!1 !== e.args[0])
                                return;
                            n.message = `Assertion failed: ${et(e.args.slice(1), " ") || "console.assert"}`,
                            n.data.arguments = e.args.slice(1)
                        }
                        Fn(n, {
                            input: e.args,
                            level: e.level
                        })
                    }
                }(t)),
                e.dom && (n = function(t, e) {
                    return function(n) {
                        if (Bt() !== t)
                            return;
                        let r, o, s = "object" == typeof e ? e.serializeAttribute : void 0, i = "object" == typeof e && "number" == typeof e.maxStringLength ? e.maxStringLength : void 0;
                        i && i > bs && (wr && m.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${i} was configured. Sentry will use 1024 instead.`),
                        i = bs),
                        "string" == typeof s && (s = [s]);
                        try {
                            const t = n.event
                              , e = function(t) {
                                return !!t && !!t.target
                            }(t) ? t.target : t;
                            r = K(e, {
                                keyAttrs: s,
                                maxStringLength: i
                            }),
                            o = Z(e)
                        } catch (t) {
                            r = "<unknown>"
                        }
                        if (0 === r.length)
                            return;
                        const a = {
                            category: `ui.${n.name}`,
                            message: r
                        };
                        o && (a.data = {
                            "ui.component_name": o
                        }),
                        Fn(a, {
                            event: n.event,
                            name: n.name,
                            global: n.global
                        })
                    }
                }(t, e.dom),
                k("dom", n),
                I("dom", Qo)),
                e.xhr && ss(function(t) {
                    return function(e) {
                        if (Bt() !== t)
                            return;
                        const {startTimestamp: n, endTimestamp: r} = e
                          , o = e.xhr[os];
                        if (!n || !r || !o)
                            return;
                        const {method: s, url: i, status_code: a, body: c} = o
                          , u = {
                            method: s,
                            url: i,
                            status_code: a
                        }
                          , d = {
                            xhr: e.xhr,
                            input: c,
                            startTimestamp: n,
                            endTimestamp: r
                        };
                        Fn({
                            category: "xhr",
                            data: u,
                            type: "http",
                            level: cr(a)
                        }, d)
                    }
                }(t)),
                e.fetch && lr(function(t) {
                    return function(e) {
                        if (Bt() !== t)
                            return;
                        const {startTimestamp: n, endTimestamp: r} = e;
                        if (r && (!e.fetchData.url.match(/sentry_key/) || "POST" !== e.fetchData.method))
                            if (e.error) {
                                Fn({
                                    category: "fetch",
                                    data: e.fetchData,
                                    level: "error",
                                    type: "http"
                                }, {
                                    data: e.error,
                                    input: e.args,
                                    startTimestamp: n,
                                    endTimestamp: r
                                })
                            } else {
                                const t = e.response
                                  , o = {
                                    ...e.fetchData,
                                    status_code: t && t.status
                                }
                                  , s = {
                                    input: e.args,
                                    response: t,
                                    startTimestamp: n,
                                    endTimestamp: r
                                };
                                Fn({
                                    category: "fetch",
                                    data: o,
                                    type: "http",
                                    level: cr(o.status_code)
                                }, s)
                            }
                    }
                }(t)),
                e.history && ts(function(t) {
                    return function(e) {
                        if (Bt() !== t)
                            return;
                        let n = e.from
                          , r = e.to;
                        const o = Qn(yr.location.href);
                        let s = n ? Qn(n) : void 0;
                        const i = Qn(r);
                        s && s.path || (s = o),
                        o.protocol === i.protocol && o.host === i.host && (r = i.relative),
                        o.protocol === s.protocol && o.host === s.host && (n = s.relative),
                        Fn({
                            category: "navigation",
                            data: {
                                from: n,
                                to: r
                            }
                        })
                    }
                }(t)),
                e.sentry && t.on("beforeSendEvent", function(t) {
                    return function(e) {
                        Bt() === t && Fn({
                            category: "sentry." + ("transaction" === e.type ? "transaction" : "event"),
                            event_id: e.event_id,
                            level: e.level,
                            message: vt(e)
                        }, {
                            event: e
                        })
                    }
                }(t))
            }
        }
    }
    ;
    const Es = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
      , ws = (t={}) => {
        const e = {
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0,
            ...t
        };
        return {
            name: "BrowserApiErrors",
            setupOnce() {
                e.setTimeout && ot(yr, "setTimeout", Ts),
                e.setInterval && ot(yr, "setInterval", Ts),
                e.requestAnimationFrame && ot(yr, "requestAnimationFrame", xs),
                e.XMLHttpRequest && "XMLHttpRequest"in yr && ot(XMLHttpRequest.prototype, "send", ks);
                const t = e.eventTarget;
                if (t) {
                    (Array.isArray(t) ? t : Es).forEach(Is)
                }
            }
        }
    }
    ;
    function Ts(t) {
        return function(...e) {
            const n = e[0];
            return e[0] = Er(n, {
                mechanism: {
                    data: {
                        function: E(t)
                    },
                    handled: !1,
                    type: "instrument"
                }
            }),
            t.apply(this, e)
        }
    }
    function xs(t) {
        return function(e) {
            return t.apply(this, [Er(e, {
                mechanism: {
                    data: {
                        function: "requestAnimationFrame",
                        handler: E(t)
                    },
                    handled: !1,
                    type: "instrument"
                }
            })])
        }
    }
    function ks(t) {
        return function(...e) {
            const n = this;
            return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((t => {
                t in n && "function" == typeof n[t] && ot(n, t, (function(e) {
                    const n = {
                        mechanism: {
                            data: {
                                function: t,
                                handler: E(e)
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    }
                      , r = at(e);
                    return r && (n.mechanism.data.handler = E(r)),
                    Er(e, n)
                }
                ))
            }
            )),
            t.apply(this, e)
        }
    }
    function Is(t) {
        const e = yr
          , n = e[t] && e[t].prototype;
        n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (ot(n, "addEventListener", (function(e) {
            return function(n, r, o) {
                try {
                    "function" == typeof r.handleEvent && (r.handleEvent = Er(r.handleEvent, {
                        mechanism: {
                            data: {
                                function: "handleEvent",
                                handler: E(r),
                                target: t
                            },
                            handled: !1,
                            type: "instrument"
                        }
                    }))
                } catch (t) {}
                return e.apply(this, [n, Er(r, {
                    mechanism: {
                        data: {
                            function: "addEventListener",
                            handler: E(r),
                            target: t
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }), o])
            }
        }
        )),
        ot(n, "removeEventListener", (function(t) {
            return function(e, n, r) {
                const o = n;
                try {
                    const n = o && o.__sentry_wrapped__;
                    n && t.call(this, e, n, r)
                } catch (t) {}
                return t.call(this, e, o, r)
            }
        }
        )))
    }
    const As = (t={}) => {
        const e = {
            onerror: !0,
            onunhandledrejection: !0,
            ...t
        };
        return {
            name: "GlobalHandlers",
            setupOnce() {
                Error.stackTraceLimit = 50
            },
            setup(t) {
                e.onerror && (!function(t) {
                    P((e => {
                        const {stackParser: n, attachStacktrace: r} = Ps();
                        if (Bt() !== t || Sr())
                            return;
                        const {msg: o, url: s, line: i, column: a, error: c} = e
                          , u = function(t, e, n, r) {
                            const o = t.exception = t.exception || {}
                              , s = o.values = o.values || []
                              , i = s[0] = s[0] || {}
                              , a = i.stacktrace = i.stacktrace || {}
                              , c = a.frames = a.frames || []
                              , u = isNaN(parseInt(r, 10)) ? void 0 : r
                              , d = isNaN(parseInt(n, 10)) ? void 0 : n
                              , p = G(e) && e.length > 0 ? e : function() {
                                try {
                                    return J.document.location.href
                                } catch (t) {
                                    return ""
                                }
                            }();
                            0 === c.length && c.push({
                                colno: u,
                                filename: p,
                                function: g,
                                in_app: !0,
                                lineno: d
                            });
                            return t
                        }($r(n, c || o, void 0, r, !1), s, i, a);
                        u.level = "error",
                        bn(u, {
                            originalException: c,
                            mechanism: {
                                handled: !1,
                                type: "onerror"
                            }
                        })
                    }
                    ))
                }(t),
                Os("onerror")),
                e.onunhandledrejection && (!function(t) {
                    D((e => {
                        const {stackParser: n, attachStacktrace: r} = Ps();
                        if (Bt() !== t || Sr())
                            return;
                        const o = function(t) {
                            if (B(t))
                                return t;
                            try {
                                if ("reason"in t)
                                    return t.reason;
                                if ("detail"in t && "reason"in t.detail)
                                    return t.detail.reason
                            } catch (t) {}
                            return t
                        }(e)
                          , s = B(o) ? {
                            exception: {
                                values: [{
                                    type: "UnhandledRejection",
                                    value: `Non-Error promise rejection captured with value: ${String(o)}`
                                }]
                            }
                        } : $r(n, o, void 0, r, !0);
                        s.level = "error",
                        bn(s, {
                            originalException: o,
                            mechanism: {
                                handled: !1,
                                type: "onunhandledrejection"
                            }
                        })
                    }
                    ))
                }(t),
                Os("onunhandledrejection"))
            }
        }
    }
    ;
    function Os(t) {
        wr && m.log(`Global Handler attached: ${t}`)
    }
    function Ps() {
        const t = Bt();
        return t && t.getOptions() || {
            stackParser: () => [],
            attachStacktrace: !1
        }
    }
    const Cs = () => ({
        name: "HttpContext",
        preprocessEvent(t) {
            if (!yr.navigator && !yr.location && !yr.document)
                return;
            const e = t.request && t.request.url || yr.location && yr.location.href
              , {referrer: n} = yr.document || {}
              , {userAgent: r} = yr.navigator || {}
              , o = {
                ...t.request && t.request.headers,
                ...n && {
                    Referer: n
                },
                ...r && {
                    "User-Agent": r
                }
            }
              , s = {
                ...t.request,
                ...e && {
                    url: e
                },
                headers: o
            };
            t.request = s
        }
    })
      , $s = (t={}) => {
        const e = t.limit || 5
          , n = t.key || "cause";
        return {
            name: "LinkedErrors",
            preprocessEvent(t, r, o) {
                const s = o.getOptions();
                Yn(Tr, s.stackParser, s.maxValueLength, n, e, t, r)
            }
        }
    }
    ;
    function Ds(t={}) {
        const e = function(t={}) {
            const e = {
                defaultIntegrations: [Vn(), Bn(), ws(), Ss(), As(), $s(), nr(), Cs()],
                release: "string" == typeof __SENTRY_RELEASE__ ? __SENTRY_RELEASE__ : yr.SENTRY_RELEASE && yr.SENTRY_RELEASE.id ? yr.SENTRY_RELEASE.id : void 0,
                autoSessionTracking: !0,
                sendClientReports: !0
            };
            return null == t.defaultIntegrations && delete t.defaultIntegrations,
            {
                ...e,
                ...t
            }
        }(t);
        if (!e.skipBrowserExtensionCheck && function() {
            const t = void 0 !== yr.window && yr;
            if (!t)
                return !1;
            const e = t[t.chrome ? "chrome" : "browser"]
              , n = e && e.runtime && e.runtime.id
              , r = yr.location && yr.location.href || ""
              , o = !!n && yr === yr.top && ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"].some((t => r.startsWith(`${t}//`)))
              , s = void 0 !== t.nw;
            return !!n && !o && !s
        }())
            return void h(( () => {
                console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
            }
            ));
        wr && (dr() || m.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."));
        const n = {
            ...e,
            stackParser: (r = e.stackParser || vs,
            Array.isArray(r) ? y(...r) : r),
            integrations: In(e),
            transport: e.transport || ps
        };
        var r;
        const o = Ln(Lr, n);
        return e.autoSessionTracking && function() {
            if (void 0 === yr.document)
                return void (wr && m.warn("Session tracking in non-browser environment with @sentry/browser is not supported."));
            Sn({
                ignoreDuration: !0
            }),
            Tn(),
            ts(( ({from: t, to: e}) => {
                void 0 !== t && t !== e && (Sn({
                    ignoreDuration: !0
                }),
                Tn())
            }
            ))
        }(),
        o
    }
    const Rs = new WeakMap
      , Ls = new Map
      , Ns = {
        traceFetch: !0,
        traceXHR: !0,
        enableHTTPTimings: !0,
        trackFetchStreamPerformance: !1
    };
    function Ms(t, e) {
        const {traceFetch: n, traceXHR: r, trackFetchStreamPerformance: o, shouldCreateSpanForRequest: s, enableHTTPTimings: i, tracePropagationTargets: a} = {
            traceFetch: Ns.traceFetch,
            traceXHR: Ns.traceXHR,
            trackFetchStreamPerformance: Ns.trackFetchStreamPerformance,
            ...e
        }
          , c = "function" == typeof s ? s : t => !0
          , u = t => function(t, e) {
            const n = yr.location && yr.location.href;
            if (n) {
                let r, o;
                try {
                    r = new URL(t,n),
                    o = new URL(n).origin
                } catch (t) {
                    return !1
                }
                const s = r.origin === o;
                return e ? rt(r.toString(), e) || s && rt(r.pathname, e) : s
            }
            {
                const n = !!t.match(/^\/(?!\/)/);
                return e ? rt(t, e) : n
            }
        }(t, a)
          , d = {};
        n && (t.addEventProcessor((t => ("transaction" === t.type && t.spans && t.spans.forEach((t => {
            if ("http.client" === t.op) {
                const e = Ls.get(t.span_id);
                e && (t.timestamp = e / 1e3,
                Ls.delete(t.span_id))
            }
        }
        )),
        t))),
        o && function(t) {
            const e = "fetch-body-resolved";
            k(e, t),
            I(e, ( () => fr(hr)))
        }((t => {
            if (t.response) {
                const e = Rs.get(t.response);
                e && t.endTimestamp && Ls.set(e, t.endTimestamp)
            }
        }
        )),
        lr((t => {
            const e = ir(t, c, u, d);
            if (t.response && t.fetchData.__span && Rs.set(t.response, t.fetchData.__span),
            e) {
                const n = qs(t.fetchData.url)
                  , r = n ? Qn(n).host : void 0;
                e.setAttributes({
                    "http.url": n,
                    "server.address": r
                })
            }
            i && e && js(e)
        }
        ))),
        r && ss((t => {
            const e = function(t, e, n, r) {
                const o = t.xhr
                  , s = o && o[os];
                if (!o || o.__sentry_own_request__ || !s)
                    return;
                const i = Oe() && e(s.url);
                if (t.endTimestamp && i) {
                    const t = o.__sentry_xhr_span_id__;
                    if (!t)
                        return;
                    const e = r[t];
                    return void (e && void 0 !== s.status_code && (te(e, s.status_code),
                    e.end(),
                    delete r[t]))
                }
                const a = qs(s.url)
                  , c = a ? Qn(a).host : void 0
                  , u = !!we()
                  , d = i && u ? an({
                    name: `${s.method} ${s.url}`,
                    attributes: {
                        type: "xhr",
                        "http.method": s.method,
                        "http.url": a,
                        url: s.url,
                        "server.address": c,
                        [Xt]: "auto.http.browser",
                        [Yt]: "http.client"
                    }
                }) : new Pe;
                o.__sentry_xhr_span_id__ = d.spanContext().spanId,
                r[o.__sentry_xhr_span_id__] = d;
                const p = Bt();
                o.setRequestHeader && n(s.url) && p && function(t, e, n) {
                    const r = Ft()
                      , o = Gt()
                      , {traceId: s, spanId: i, sampled: a, dsc: c} = {
                        ...o.getPropagationContext(),
                        ...r.getPropagationContext()
                    }
                      , u = n && Oe() ? le(n) : ue(s, i, a)
                      , d = se(c || (n ? Le(n) : Re(s, e)));
                    !function(t, e, n) {
                        try {
                            t.setRequestHeader("sentry-trace", e),
                            n && t.setRequestHeader(ee, n)
                        } catch (t) {}
                    }(t, u, d)
                }(o, p, Oe() && u ? d : void 0);
                return d
            }(t, c, u, d);
            i && e && js(e)
        }
        ))
    }
    function js(t) {
        const {url: e} = me(t).data || {};
        if (!e || "string" != typeof e)
            return;
        const n = To("resource", ( ({entries: r}) => {
            r.forEach((r => {
                if (function(t) {
                    return "resource" === t.entryType && "initiatorType"in t && "string" == typeof t.nextHopProtocol && ("fetch" === t.initiatorType || "xmlhttprequest" === t.initiatorType)
                }(r) && r.name.endsWith(e)) {
                    (function(t) {
                        const {name: e, version: n} = function(t) {
                            let e = "unknown"
                              , n = "unknown"
                              , r = "";
                            for (const o of t) {
                                if ("/" === o) {
                                    [e,n] = t.split("/");
                                    break
                                }
                                if (!isNaN(Number(o))) {
                                    e = "h" === r ? "http" : r,
                                    n = t.split(r)[1];
                                    break
                                }
                                r += o
                            }
                            r === t && (e = r);
                            return {
                                name: e,
                                version: n
                            }
                        }(t.nextHopProtocol)
                          , r = [];
                        if (r.push(["network.protocol.version", n], ["network.protocol.name", e]),
                        !mt)
                            return r;
                        return [...r, ["http.request.redirect_start", Us(t.redirectStart)], ["http.request.fetch_start", Us(t.fetchStart)], ["http.request.domain_lookup_start", Us(t.domainLookupStart)], ["http.request.domain_lookup_end", Us(t.domainLookupEnd)], ["http.request.connect_start", Us(t.connectStart)], ["http.request.secure_connection_start", Us(t.secureConnectionStart)], ["http.request.connection_end", Us(t.connectEnd)], ["http.request.request_start", Us(t.requestStart)], ["http.request.response_start", Us(t.responseStart)], ["http.request.response_end", Us(t.responseEnd)]]
                    }
                    )(r).forEach((e => t.setAttribute(...e))),
                    setTimeout(n)
                }
            }
            ))
        }
        ))
    }
    function Us(t=0) {
        return ((mt || performance.timeOrigin) + t) / 1e3
    }
    function qs(t) {
        try {
            return new URL(t,yr.location.origin).href
        } catch (t) {
            return
        }
    }
    const Fs = {
        ...pn,
        instrumentNavigation: !0,
        instrumentPageLoad: !0,
        markBackgroundSpan: !0,
        enableLongTask: !0,
        enableLongAnimationFrame: !0,
        enableInp: !0,
        _experiments: {},
        ...Ns
    }
      , Gs = (t={}) => {
        Te || (Te = !0,
        P(xe),
        D(xe));
        const {enableInp: e, enableLongTask: n, enableLongAnimationFrame: r, _experiments: {enableInteractions: o, enableStandaloneClsSpans: s}, beforeStartSpan: i, idleTimeout: a, finalTimeout: c, childSpanTimeout: d, markBackgroundSpan: p, traceFetch: l, traceXHR: f, trackFetchStreamPerformance: h, shouldCreateSpanForRequest: g, enableHTTPTimings: _, instrumentPageLoad: v, instrumentNavigation: y} = {
            ...Fs,
            ...t
        }
          , b = Bo({
            recordClsStandaloneSpans: s || !1
        });
        e && us(),
        r && u.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? new PerformanceObserver((t => {
            const e = we();
            if (e)
                for (const n of t.getEntries()) {
                    if (!n.scripts[0])
                        continue;
                    const t = jo(mt + n.startTime)
                      , {start_timestamp: r, op: o} = me(e);
                    if ("navigation" === o && r && t < r)
                        continue;
                    const s = jo(n.duration)
                      , i = {
                        [Xt]: "auto.ui.browser.metrics"
                    }
                      , a = n.scripts[0]
                      , {invoker: c, invokerType: u, sourceURL: d, sourceFunctionName: p, sourceCharPosition: l} = a;
                    i["browser.script.invoker"] = c,
                    i["browser.script.invoker_type"] = u,
                    d && (i["code.filepath"] = d),
                    p && (i["code.function"] = p),
                    -1 !== l && (i["browser.script.source_char_position"] = l),
                    Lo(e, t, t + s, {
                        name: "Main UI thread blocked",
                        op: "ui.long-animation-frame",
                        attributes: i
                    })
                }
        }
        )).observe({
            type: "long-animation-frame",
            buffered: !0
        }) : n && To("longtask", ( ({entries: t}) => {
            const e = we();
            if (!e)
                return;
            const {op: n, start_timestamp: r} = me(e);
            for (const o of t) {
                const t = jo(mt + o.startTime)
                  , s = jo(o.duration);
                "navigation" === n && r && t < r || Lo(e, t, t + s, {
                    name: "Main UI thread blocked",
                    op: "ui.long-task",
                    attributes: {
                        [Xt]: "auto.ui.browser.metrics"
                    }
                })
            }
        }
        )),
        o && To("event", ( ({entries: t}) => {
            const e = we();
            if (e)
                for (const n of t)
                    if ("click" === n.name) {
                        const t = jo(mt + n.startTime)
                          , r = jo(n.duration)
                          , o = {
                            name: K(n.target),
                            op: `ui.interaction.${n.name}`,
                            startTime: t,
                            attributes: {
                                [Xt]: "auto.ui.browser.metrics"
                            }
                        }
                          , s = Z(n.target);
                        s && (o.attributes["ui.component_name"] = s),
                        Lo(e, t, t + r, o)
                    }
        }
        ));
        const S = {
            name: void 0,
            source: void 0
        };
        function E(t, e) {
            const n = "pageload" === e.op
              , r = i ? i(e) : e
              , o = r.attributes || {};
            e.name !== r.name && (o[Vt] = "custom",
            r.attributes = o),
            S.name = r.name,
            S.source = o[Vt];
            const u = ln(r, {
                idleTimeout: a,
                finalTimeout: c,
                childSpanTimeout: d,
                disableAutoFinish: n,
                beforeSpanEnd: t => {
                    b(),
                    zo(t, {
                        recordClsOnPageloadSpan: !s
                    })
                }
            });
            function p() {
                ["interactive", "complete"].includes(yr.document.readyState) && t.emit("idleSpanEnableAutoFinish", u)
            }
            return n && yr.document && (yr.document.addEventListener("readystatechange", ( () => {
                p()
            }
            )),
            p()),
            u
        }
        return {
            name: "BrowserTracing",
            afterAllSetup(t) {
                let n, r = yr.location && yr.location.href;
                t.on("startNavigationSpan", (e => {
                    Bt() === t && (n && !me(n).timestamp && (wr && m.log(`[Tracing] Finishing current root span with op: ${me(n).op}`),
                    n.end()),
                    n = E(t, {
                        op: "navigation",
                        ...e
                    }))
                }
                )),
                t.on("startPageLoadSpan", ( (e, r={}) => {
                    if (Bt() !== t)
                        return;
                    n && !me(n).timestamp && (wr && m.log(`[Tracing] Finishing current root span with op: ${me(n).op}`),
                    n.end());
                    const o = ce(r.sentryTrace || Hs("sentry-trace"), r.baggage || Hs("baggage"));
                    Ft().setPropagationContext(o),
                    n = E(t, {
                        op: "pageload",
                        ...e
                    })
                }
                )),
                t.on("spanEnd", (t => {
                    const e = me(t).op;
                    if (t !== Ee(t) || "navigation" !== e && "pageload" !== e)
                        return;
                    const n = Ft()
                      , r = n.getPropagationContext();
                    n.setPropagationContext({
                        ...r,
                        sampled: void 0 !== r.sampled ? r.sampled : ge(t),
                        dsc: r.dsc || Le(t)
                    })
                }
                )),
                yr.location && (v && function(t, e, n) {
                    t.emit("startPageLoadSpan", e, n),
                    Ft().setTransactionName(e.name);
                    const r = we();
                    r && me(r).op
                }(t, {
                    name: yr.location.pathname,
                    startTime: mt ? mt / 1e3 : void 0,
                    attributes: {
                        [Vt]: "url",
                        [Xt]: "auto.pageload.browser"
                    }
                }),
                y && ts(( ({to: e, from: n}) => {
                    void 0 === n && r && -1 !== r.indexOf(e) ? r = void 0 : n !== e && (r = void 0,
                    function(t, e) {
                        Gt().setPropagationContext(At()),
                        Ft().setPropagationContext(At()),
                        t.emit("startNavigationSpan", e),
                        Ft().setTransactionName(e.name);
                        const n = we();
                        n && me(n).op
                    }(t, {
                        name: yr.location.pathname,
                        attributes: {
                            [Vt]: "url",
                            [Xt]: "auto.navigation.browser"
                        }
                    }))
                }
                ))),
                p && (yr && yr.document ? yr.document.addEventListener("visibilitychange", ( () => {
                    const t = we();
                    if (!t)
                        return;
                    const e = Ee(t);
                    if (yr.document.hidden && e) {
                        const t = "cancelled"
                          , {op: n, status: r} = me(e);
                        wr && m.log(`[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${n}`),
                        r || e.setStatus({
                            code: 2,
                            message: t
                        }),
                        e.setAttribute("sentry.cancellation_reason", "document.hidden"),
                        e.end()
                    }
                }
                )) : wr && m.warn("[Tracing] Could not set up background tab detection due to lack of global document")),
                o && function(t, e, n, r) {
                    let o;
                    const s = () => {
                        const s = "ui.action.click"
                          , i = we()
                          , a = i && Ee(i);
                        if (a) {
                            const t = me(a).op;
                            if (["navigation", "pageload"].includes(t))
                                return void (wr && m.warn(`[Tracing] Did not create ${s} span because a pageload or navigation span is in progress.`))
                        }
                        o && (o.setAttribute(Jt, "interactionInterrupted"),
                        o.end(),
                        o = void 0),
                        r.name ? o = ln({
                            name: r.name,
                            op: s,
                            attributes: {
                                [Vt]: r.source || "url"
                            }
                        }, {
                            idleTimeout: t,
                            finalTimeout: e,
                            childSpanTimeout: n
                        }) : wr && m.warn(`[Tracing] Did not create ${s} transaction because _latestRouteName is missing.`)
                    }
                    ;
                    yr.document && addEventListener("click", s, {
                        once: !1,
                        capture: !0
                    })
                }(a, c, d, S),
                e && function() {
                    const t = ({entries: t}) => {
                        const e = we()
                          , n = e && Ee(e);
                        t.forEach((t => {
                            if (!function(t) {
                                return "duration"in t
                            }(t) || !n)
                                return;
                            const e = t.interactionId;
                            if (null != e && !cs.has(e)) {
                                if (as.length > 10) {
                                    const t = as.shift();
                                    cs.delete(t)
                                }
                                as.push(e),
                                cs.set(e, n)
                            }
                        }
                        ))
                    }
                    ;
                    To("event", t),
                    To("first-input", t)
                }(),
                Ms(t, {
                    traceFetch: l,
                    traceXHR: f,
                    trackFetchStreamPerformance: h,
                    tracePropagationTargets: t.getOptions().tracePropagationTargets,
                    shouldCreateSpanForRequest: g,
                    enableHTTPTimings: _
                })
            }
        }
    }
    ;
    function Hs(t) {
        const e = (n = `meta[name=${t}]`,
        J.document && J.document.querySelector ? J.document.querySelector(n) : null);
        var n;
        return e ? e.getAttribute("content") : void 0
    }
    var Bs;
    !function(t) {
        t.FACEBOOK = "facebook",
        t.GOOGLE = "google",
        t.SEGMENT = "segment"
    }(Bs || (Bs = {}));
    var zs = [];
    function Vs(t) {
        var e = {
            event_request_url: t
        };
        try {
            new URL(t).searchParams.forEach((function(t, n) {
                e[n] = decodeURIComponent(t)
            }
            ))
        } catch (t) {
            i("error", "Error parsing URL parameters:", t),
            yn(t)
        }
        return e
    }
    function Ws(t) {
        void 0 === t && (t = []),
        zs = t
    }
    function Ys(t, e) {
        if (!t)
            return !0;
        var n = zs;
        try {
            for (var r = new URL(t).hostname, o = 0, s = n; o < s.length; o++) {
                var a = s[o];
                try {
                    if (r === new URL(a).hostname)
                        return !0
                } catch (t) {
                    if (r === a || r.endsWith(".".concat(a)))
                        return !0
                }
            }
            return !1
        } catch (t) {
            return i("error", "Error parsing URL in shouldSkipUrl:", t),
            !1
        }
    }
    function Xs(t, e, n) {
        try {
            if (!window.PerformanceObserver)
                return void i("info", "PerformanceObserver not supported in this browser");
            new PerformanceObserver((function(r) {
                r.getEntries().forEach((function(r) {
                    try {
                        var o = r;
                        if (!t.includes(o.initiatorType))
                            return;
                        var s = o.name;
                        if (!e(s))
                            return;
                        if (Ys(s))
                            return void i("info", "Skipping excluded URL: ".concat(s));
                        n(s)
                    } catch (t) {
                        i("error", "Error processing performance entry:", t),
                        yn(t)
                    }
                }
                ))
            }
            )).observe({
                entryTypes: ["resource"]
            }),
            i("info", "PerformanceObserver set up for ".concat(t.join(", "), " resources"))
        } catch (t) {
            i("error", "Error setting up PerformanceObserver:", t),
            yn(t)
        }
    }
    var Js, Ks = !1;
    !function(t) {
        t.FACEBOOK_PIXEL = "facebook.com/tr",
        t.GOOGLE_ADDS_SERVICES_PAGEAD = "googleadservices.com/pagead",
        t.DOUBLECLICK_PAGEAD = "googleads.g.doubleclick.net/pagead",
        t.GOOGLE_PAGEAD = "google.com/pagead"
    }(Js || (Js = {}));
    var Qs = null;
    function Zs(t, e, n) {
        i("info", "wrapImage called with adsProviders: ", t),
        0 !== t.length && (Ks || (Ks = !0,
        Ws(n || []),
        Qs = e,
        window.PerformanceObserver ? (i("info", "Using PerformanceObserver for ad network pixel monitoring (non-invasive approach)"),
        Xs(["img"], ei, ti)) : (i("info", "PerformanceObserver not supported, falling back to limited image wrapping"),
        function(t) {
            i("info", "setupLimitedImageWrapping called with adsProviders: ", t);
            try {
                var e = t.includes(Bs.FACEBOOK)
                  , n = t.includes(Bs.GOOGLE);
                if (!e && !n)
                    return;
                var r = Object.getOwnPropertyDescriptor(Image.prototype, "src");
                Object.defineProperty(Image.prototype, "src", {
                    set: function(t) {
                        r && r.set ? r.set.call(this, t) : this._src = t;
                        try {
                            if (!ei(t))
                                return;
                            if (Ys(t))
                                return void i("info", "Skipping excluded ad network URL in image wrapper: ".concat(t));
                            ti(t)
                        } catch (t) {
                            i("error", "Error in ad network pixel processing:", t),
                            yn(t)
                        }
                    },
                    get: function() {
                        return r && r.get ? r.get.call(this) : this._src
                    }
                }),
                i("info", "Limited image interception set up for ad network URLs")
            } catch (t) {
                i("error", "Error setting up limited image interception:", t),
                yn(t)
            }
        }(t)),
        i("info", "Ad network pixel monitoring initialized")))
    }
    function ti(t) {
        if (Qs) {
            var e = function(t) {
                if (t.includes("https://www.googleadservices.com/pagead"))
                    return Js.GOOGLE_ADDS_SERVICES_PAGEAD;
                if (t.includes("https://googleads.g.doubleclick.net/pagead"))
                    return Js.DOUBLECLICK_PAGEAD;
                if (t.includes("https://www.google.com/pagead"))
                    return Js.GOOGLE_PAGEAD;
                if (t.includes("https://www.facebook.com/tr"))
                    return Js.FACEBOOK_PIXEL;
                return
            }(t);
            if (e)
                try {
                    var n = new URL(t).pathname.split("/").map(decodeURIComponent).filter((function(t) {
                        return "" !== t
                    }
                    ))
                      , r = function(t, e, n) {
                        var r = Vs(t);
                        try {
                            Js.isGoogleSource(e) && n.length > 2 && (r[n[1]] = n[2])
                        } catch (t) {
                            yn(t),
                            i("error", "Error extracting event params:", t)
                        }
                        return r
                    }(t, e, n)
                      , o = function(t, e, n) {
                        if (Js.isGoogleSource(e) && n.length > 2)
                            return n[1];
                        return t.ev || t.event || t.event_name || "unknown"
                    }(r, e, n);
                    Qs(e, o, r)
                } catch (t) {
                    i("error", "Error processing ad network pixel:", t),
                    yn(t)
                }
        }
    }
    function ei(t) {
        return !!t && (t.includes("facebook.com/tr") || t.includes("googleadservices.com/pagead") || t.includes("googleads.g.doubleclick.net/pagead") || t.includes("google.com/pagead"))
    }
    !function(t) {
        t.isGoogleSource = function(e) {
            switch (e) {
            case t.GOOGLE_ADDS_SERVICES_PAGEAD:
            case t.DOUBLECLICK_PAGEAD:
            case t.GOOGLE_PAGEAD:
                return !0;
            default:
                return !1
            }
        }
    }(Js || (Js = {}));
    var ni, ri = !1;
    !function(t) {
        t.G_COLLECT = "analytics.google.com/g/collect",
        t.CCM_COLLECT = "analytics.google.com/ccm/collect",
        t.SEGMENT = "api.segment.io"
    }(ni || (ni = {}));
    var oi = null;
    function si(t, e, n) {
        i("info", "wrapWindowFetch called with adsProviders: ", t),
        (t.includes(Bs.GOOGLE) || t.includes(Bs.SEGMENT)) && (ri || (ri = !0,
        Ws(n || []),
        oi = e,
        i("info", "Setting up Google Analytics and Segment monitoring (non-invasive)"),
        window.PerformanceObserver ? (i("info", "Using PerformanceObserver for Google Analytics and Segment monitoring (non-invasive approach)"),
        Xs(["fetch", "xmlhttprequest"], ii, (function(t) {
            return ci(t, void 0)
        }
        )),
        ai(!0)) : (i("info", "PerformanceObserver not supported, falling back to limited fetch interception"),
        ai(!1)),
        i("info", "Google Analytics and Segment monitoring initialized (non-invasive approach)")))
    }
    function ii(t) {
        return t.includes("analytics.google.com")
    }
    function ai(t) {
        try {
            var e = window.fetch;
            window.fetch = function(n, r) {
                return o(this, void 0, void 0, (function() {
                    var o, a, c;
                    return s(this, (function(s) {
                        if (("string" == typeof n || n instanceof URL) && (o = n.toString(),
                        console.log("window.fetch url", o),
                        function(t, e) {
                            return e ? t.includes("api.segment.io") : t.includes("analytics.google.com") || t.includes("api.segment.io")
                        }(o, t) && !Ys(o)))
                            try {
                                if (a = void 0,
                                console.log("window.fetch callback - init?.body", null == r ? void 0 : r.body),
                                (null == r ? void 0 : r.body) && "string" == typeof (null == r ? void 0 : r.body))
                                    try {
                                        a = JSON.parse((null === (c = null == r ? void 0 : r.body) || void 0 === c ? void 0 : c.toString()) || "{}")
                                    } catch (t) {
                                        i("error", "Error parsing window.fetch init?.body as json:", t),
                                        yn(t)
                                    }
                                ci(o, a)
                            } catch (t) {
                                i("error", "Error in Google Analytics and Segment processing:", t),
                                yn(t)
                            }
                        return [2, e.apply(this, [n, r])]
                    }
                    ))
                }
                ))
            }
            ,
            i("info", "Limited fetch interception set up for Google Analytics and Segment URLs")
        } catch (t) {
            i("error", "Error setting up limited fetch interception:", t),
            yn(t)
        }
    }
    function ci(t, e) {
        if (oi) {
            var n = function(t) {
                var e = "https://analytics.google.com";
                if (t.includes("".concat(e, "/g/collect")))
                    return ni.G_COLLECT;
                if (t.includes("".concat(e, "/ccm/collect")))
                    return ni.CCM_COLLECT;
                if (t.includes("api.segment.io"))
                    return ni.SEGMENT;
                return
            }(t);
            if (n) {
                var o, s = function(t, e) {
                    var n = Vs(t);
                    if (e)
                        return r(r({}, n), e);
                    return n
                }(t, e), i = (o = s).en || o.event_name || o.event || "unknown";
                oi(n, i, s)
            }
        }
    }
    function ui(t, e, n) {
        window.fetch && "function" == typeof window.fetch ? function(t, e, n) {
            var r = {
                "Content-Type": "application/json",
                "X-Api-Key": n
            };
            i("info", "Sending event to Voyantis events handler:", e, r),
            fetch(t, {
                method: "POST",
                headers: r,
                body: e,
                mode: "cors"
            }).catch((function(t) {
                i("error", "Error sending event to Voyantis events handler:", t),
                yn(t)
            }
            ))
        }(t, e, n) : function(t, e, n) {
            i("info", "Using XHR to send event to Voyantis events handler:", e);
            var r = new XMLHttpRequest;
            r.open("POST", t, !0),
            r.setRequestHeader("Content-Type", "application/json"),
            r.setRequestHeader("X-Api-Key", n),
            r.onreadystatechange = function() {
                4 === r.readyState && (r.status >= 200 && r.status < 300 ? i("info", "Event sent successfully via XHR") : i("error", "Error sending event via XHR:", r.statusText))
            }
            ,
            r.onerror = function() {
                i("error", "Network error sending event to Voyantis events handler (XHR).:", r.statusText);
                var t = new Error("Request failed with status: ".concat(r.status));
                return yn(t),
                t
            }
            ,
            r.send(e)
        }(t, e, n)
    }
    function di(t, e, n, r) {
        i("info", "Initializing Voyantis event monitoring:", t, e);
        var o = function(o, s, a) {
            r.skipEvents && r.skipEvents.includes(s) ? i("info", "Skipping event forwarding because of a feature flag:", s) : s && "unknown" !== s ? a && 0 !== Object.keys(a).length ? function(t, e, n, r, o, s, a) {
                void 0 === a && (a = !0);
                try {
                    var c = function(t, e, n, r, o, s) {
                        return JSON.stringify({
                            name: "event",
                            info: {
                                event_name: t,
                                event_data: e
                            },
                            env_name: r,
                            source: n,
                            mapClientIP: s,
                            version: "".concat(o),
                            timestamp: (new Date).toISOString()
                        })
                    }(t, e, n, s, r, a)
                      , u = function(t) {
                        var e = "https://webhooks.voyantis.io";
                        return "staging" === t ? "".concat(e, "/").concat(t) : e
                    }(s);
                    ui(u, c, o)
                } catch (t) {
                    i("error", "Error forwarding event to Voyantis:", t),
                    yn(t)
                }
            }(s || "unknown", a, o, n, e, t, r.mapClientIp) : i("info", "Empty event params, skipping event forwarding:", s) : i("info", "Unknown event name, skipping event forwarding:", a)
        };
        Zs(r.wrapAdsProviders, o, r.excludedUrls),
        si(r.wrapAdsProviders, o, r.excludedUrls),
        i("info", "Voyantis event monitoring initialized successfully")
    }
    return t.init = function(t, r, a) {
        return o(this, arguments, void 0, (function(t, r, o, a) {
            var c;
            return void 0 === a && (a = "prod"),
            s(this, (function(t) {
                if ((c = JSON.parse('{\n  "wrapAdsProviders": [\n    "facebook",\n    "google"\n  ],\n  "skipEvents": [\n    "scroll",\n    "page_view",\n    "pageView",\n    "PageView",\n    "hover",\n    "click",\n    "show",\n    "1p-user-list",\n    "apply_filter",\n    "form_start",\n    "video_progress",\n    "view_search_results"\n  ],\n  "excludedUrls": [\n    "semrush.com"\n  ],\n  "sentryEnabled": false,\n  "mapClientIp": false\n}')).sentryEnabled)
                    try {
                        Ds({
                            dsn: "https://9b22608edb04a501987da32b2bd58857@o1079650.ingest.us.sentry.io/4508341778972672",
                            integrations: [Gs()],
                            sampleRate: .1
                        })
                    } catch (t) {
                        console.log("Error initializing Sentry: ", t)
                    }
                try {
                    !function(t, r) {
                        e = t,
                        n = r
                    }(a, r),
                    i("info", "Voyantis core SDK INIT in client bundle", o, a, c),
                    di(a, o, r, c)
                } catch (t) {
                    i("error", "Error initializing Voyantis SDK:", t),
                    yn(t)
                }
                return [2]
            }
            ))
        }
        ))
    }
    ,
    t
}({});
//# sourceMappingURL=vy-cs-sdk.min.js.map
